<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>kotlin on Marcello Galhardo</title><link>https://marcellogalhardo.dev/tags/kotlin/</link><description>Recent content in kotlin on Marcello Galhardo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 25 Mar 2023 09:02:50 +0100</lastBuildDate><atom:link href="https://marcellogalhardo.dev/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Namespace for Extension Functions</title><link>https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/</link><pubDate>Sat, 25 Mar 2023 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/</guid><description>A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a ~Gradle~ module was out of scope. Introducing a new type to hold the function felt too much. Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?</description></item><item><title>Deep Models</title><link>https://marcellogalhardo.dev/posts/2021/10/07/deep-models/</link><pubDate>Thu, 07 Oct 2021 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/posts/2021/10/07/deep-models/</guid><description>Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on &amp;ldquo;How can I code this?&amp;rdquo;, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.
To better explain, let&amp;rsquo;s consider the hypothetical requirements:</description></item><item><title>Humble Views, Proud ViewModels</title><link>https://marcellogalhardo.dev/posts/2021/02/01/humble-views-proud-viewmodels/</link><pubDate>Mon, 01 Feb 2021 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/posts/2021/02/01/humble-views-proud-viewmodels/</guid><description>The Android Community has long advocated that Activities and Fragments were viewsâ€Š- but this perception has changed over time. For good. Let&amp;rsquo;s dive deep into how to design views and view models, how they wire to a LifecycleOwner, and how this can positively impact your&amp;rsquo;s app testability.
To better describe how to build humble views we will be developing an elementary Sign-Up form with an email, a password text field and two buttons: a cancel that pops the user&amp;rsquo;s back stack and a sign up that creates an account and moves the user to the home screen.</description></item><item><title>Naming Factory Methods</title><link>https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/</link><pubDate>Sat, 01 Feb 2020 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/</guid><description>When talking about Factory Methods, extension functions tend to be favored in Kotlin - but it might be a challenge to name these functions in a discoverable way without polluting your project&amp;rsquo;s namespace. A good source of inspiration is Kotlin&amp;rsquo;s Standard library: it contains many examples we can use as a base when deciding how to design a function.
Wrapping an instance If you intend to get a given instance and adapt to one different object to follow another contract, for example, creating a ViewModelProvider.</description></item></channel></rss>