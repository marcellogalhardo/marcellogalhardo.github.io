<!doctype html><html lang=en-us data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Factory Methods in Kotlin - Marcello Galhardo</title><meta name=description content="Marcello's Personal Blog"><link rel=icon type=image/x-icon href=https://marcellogalhardo.dev/favicon.ico><link rel=apple-touch-icon-precomposed href=https://marcellogalhardo.dev/favicon.png><link rel=stylesheet href=https://marcellogalhardo.dev/css/style.1d8233f454bf6bbf46abed7023dbbba557fc4af5f1e39de066ac496c94409622.css integrity="sha256-HYIz9FS/a79Gq+1wI9u7pVf8SvXx453gZqxJbJRAliI="><meta property="og:title" content="Factory Methods in Kotlin"><meta property="og:description" content="When talking about Factory Methods extension functions tends to be favored in Kotlin - but it might be a challenge to name these functions in a discoverable way without polluting your classpath. Therefore, we can get inspiration on Kotlin&rsquo;s Standard library to improve our naming.
Wrapping an instance If your intention is to get a given instance, for example javax.inject.Provider, create an instance of ViewModelProvider.Factory which internally uses it: you want a wrapper."><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/blog/2020/02/01/factory-methods-in-kotlin/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-02-01T09:02:50+01:00"><meta property="article:modified_time" content="2020-02-01T09:02:50+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Factory Methods in Kotlin"><meta name=twitter:description content="When talking about Factory Methods extension functions tends to be favored in Kotlin - but it might be a challenge to name these functions in a discoverable way without polluting your classpath. Therefore, we can get inspiration on Kotlin&rsquo;s Standard library to improve our naming.
Wrapping an instance If your intention is to get a given instance, for example javax.inject.Provider, create an instance of ViewModelProvider.Factory which internally uses it: you want a wrapper."></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><h1 class=site-title><a href=/>Marcello Galhardo</a></h1><nav><a href=https://marcellogalhardo.dev/blog/ title>Blog</a>
<a href=https://marcellogalhardo.dev/about title>About</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><header class=post-header><h1 class="p-name post-title">Factory Methods in Kotlin</h1></header><div class="content e-content"><p>When talking about Factory Methods extension functions tends to be favored in Kotlin - but it might be a challenge to name these functions in a discoverable way without polluting your classpath. Therefore, we can get inspiration on Kotlin&rsquo;s Standard library to improve our naming.</p><h2 id=wrapping-an-instance>Wrapping an instance</h2><p>If your intention is to get a given instance, for example <code>javax.inject.Provider</code>, create an instance of <code>ViewModelProvider.Factory</code> which internally uses it: you want a wrapper. Looking inside Kotlin&rsquo;s Standard library we can find <a href=https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-executor.html>asExecutor</a> which does exactly the same.</p><p>That said, a good way of doing it is:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>VM</span> : <span style=color:#a6e22e>ViewModel</span>&gt; <span style=color:#a6e22e>Provider</span>&lt;<span style=color:#66d9ef>out</span> VM&gt;.asViewModelFactory(): ViewModelProvider.Factory {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>ViewModelProvider</span>.Factory {
        <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span> : <span style=color:#a6e22e>ViewModel</span>?&gt; <span style=color:#a6e22e>create</span>(modelClass: Class&lt;T&gt;): T {
            <span style=color:#a6e22e>@Suppress</span>(<span style=color:#e6db74>&#34;UNCHECKED_CAST&#34;</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>() <span style=color:#66d9ef>as</span> T
        }
    }
}
</code></pre></div><h2 id=mapping-data>Mapping data</h2><p>When your intention is to copy the data of a given instance, for example <code>UserDto</code>, into a new instance like <code>User</code> (domain model): you want a mapper. Again, Kotlin&rsquo;s Standard library give us a good example with <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/to-list.html?_ga=2.130355144.672183661.1577982073-802284527.1577800392">toList</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>UserDto</span>.toUser(): User {
    <span style=color:#66d9ef>return</span> User(
        name = Name(
            first = <span style=color:#66d9ef>this</span>.firstName,
            last = <span style=color:#66d9ef>this</span>.lastName
        ),
        email = Email(<span style=color:#66d9ef>this</span>.email)
        age = <span style=color:#66d9ef>this</span>.age
    )
}
</code></pre></div><h2 id=vararg-constructors>Vararg constructors</h2><p>Maybe you want to provide a secondary constructor which accept a vararg of that list of parameters but you don&rsquo;t want to pollute your class code which such a small and optional thing. Kotlin&rsquo;s Standard Library offer us the convenient <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html?_ga=2.139095028.672183661.1577982073-802284527.1577800392">listOf</a> as an example.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span> : <span style=color:#a6e22e>Controller</span>&gt; <span style=color:#a6e22e>compositeControllerOf</span>(<span style=color:#66d9ef>vararg</span> providers: Provider&lt;T&gt;) = 
    CompositeControllerFactory(providers.toList())
</code></pre></div><h2 id=builders>Builders</h2><p>Last but not least, Kotlin&rsquo;s constructor combined with named parameter covers most use cases of the Builder Design Pattern. However, sometimes you might want to create an instance which constructors are not suitable - for example, with a lot of optionals and configurable attributes where you want to provide alternative combinations (maybe accepting URL or URI). For that cases, we can use <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/build-string.html>buildString</a> as an example.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>buildImageLoader</span>(
    builderAction: ImageLoaderBuilder.() <span style=color:#f92672>-&gt;</span> Unit
): String

<span style=color:#75715e>// usage example
</span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>val</span> validUri = <span style=color:#75715e>// receives a valid URI object
</span><span style=color:#75715e></span>    buildImageLoader {
        uri = validUri
        loadingPlaceholder = R.drawable.loading_placeholder
        errorPlaceholder = R.drawable.error_placeholder
    }
}
</code></pre></div><h1 id=conclusion>Conclusion</h1><p>As you can see, the Kotlin Standard library can be a good source of inspiration when designing code aiming for better discoverability between Kotlin Developers through the consistent pattern the language follows. Why not take advantage of that?</p></div><div class=post-info><div class="post-date dt-published">2020-02-01</div><a class="post-hidden-url u-url" href=https://marcellogalhardo.dev/blog/2020/02/01/factory-methods-in-kotlin/>https://marcellogalhardo.dev/blog/2020/02/01/factory-methods-in-kotlin/</a>
<a href=https://marcellogalhardo.dev/ class="p-name p-author post-hidden-author h-card" rel=me>Marcello Galhardo</a><div class=post-taxonomies></div></div></article><div class="pagination post-pagination"><div class="left pagination-item"><a href=/blog/2021/02/01/humble-views-proud-viewmodels/>Humble Views Proud ViewModels</a></div><div class="right pagination-item"><a href=/blog/2020/01/01/dagger-viewmodels-and-fragments/>Dagger, ViewModels and Fragments</a></div></div></main><footer class=common-footer><div class=common-footer-bottom><div class=copyright><p>Â© Marcello Galhardo, 2021<br>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.<br></p></div></div><p class="h-card vcard"><a href=https://marcellogalhardo.dev/ class="p-name u-url url fn" rel=me>Marcello Galhardo</a>
/
<a class="p-email u-email email" rel=me href=mailto:marcello.galhardo@gmail.com>marcello.galhardo@gmail.com</a>
<img class=u-photo src="https://avatars3.githubusercontent.com/u/4348197?s=460&v=4"></p></footer></div></body></html>