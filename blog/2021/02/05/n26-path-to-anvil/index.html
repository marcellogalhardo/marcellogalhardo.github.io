<!doctype html><html lang=en-us data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>N26 Path to Anvil - Marcello Galhardo</title><meta name=description content="Marcello's Personal Blog"><link rel=icon type=image/x-icon href=http://example.org/favicon.ico><link rel=apple-touch-icon-precomposed href=http://example.org/favicon.png><link rel=stylesheet href=http://example.org/css/style.1d8233f454bf6bbf46abed7023dbbba557fc4af5f1e39de066ac496c94409622.css integrity="sha256-HYIz9FS/a79Gq+1wI9u7pVf8SvXx453gZqxJbJRAliI="><meta property="og:title" content="N26 Path to Anvil"><meta property="og:description" content="This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.
N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;Sample Apps&rdquo; for years now as our full app build time might take up to 20 minutes."><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/blog/2021/02/05/n26-path-to-anvil/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-02-05T09:02:50+01:00"><meta property="article:modified_time" content="2021-02-05T09:02:50+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="N26 Path to Anvil"><meta name=twitter:description content="This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.
N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;Sample Apps&rdquo; for years now as our full app build time might take up to 20 minutes."></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><h1 class=site-title><a href=/>Marcello Galhardo</a></h1><nav><a href=http://example.org/blog/ title>Blog</a>
<a href=http://example.org/about title>About</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><header class=post-header><h1 class="p-name post-title">N26 Path to Anvil</h1></header><div class="content e-content"><p>This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.</p><p>N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;<a href=https://cashapp.github.io/2020-08-25/attacking-build-times-with-sample-apps>Sample Apps</a>&rdquo; for years now as our full app build time might take up to 20 minutes.</p><p>Today I will share a little about my story with Dagger inside the company, why we adopt Anvil, some of the challenges we faced, and how are the results so far.</p><h1 id=dagger-oh-my>Dagger, (oh, my)</h1><p>N26 has a long history with Dagger. We have been using it for years, we developed our customizations and libraries on top of it, and many of our architectural decisions were made relying on Dagger features.</p><p>Dagger is excellent but comes with a price when used with Kotlin. The more we grew, the more we were charged. Stub generation issues, slow build time, increasing boilerplate to wire <code>@dagger.Component</code>, new joiners avoided touching the graphs due to complexity&mldr;</p><p>Looking for solutions, we found <a href=https://dagger.dev/hilt/>Hilt by Google</a>. We enjoyed many of the ideas they proposed as the <a href=https://dagger.dev/hilt/monolithic.html>Monolithic Component</a> and the <a href=https://dagger.dev/hilt/testing.html>testing philosophy</a>. But the trade-off was not that good for us: a migration would be painful and would take months to years, to not say we did not appreciate the byte code manipulation and the extra KAPT processor.</p><p>Simultaneously, another solution appeared, which solved some of the same problems differently: <a href=https://github.com/square/anvil>Anvil</a>.</p><blockquote><p>Anvil is a Kotlin compiler plugin to make dependency injection with Dagger easier by automatically merging Dagger modules and component interfaces.</p></blockquote><h1 id=sharpening-your-blade>Sharpening your blade</h1><p>To get an idea of how Anvil would affect us, we started with a set of experiments. The first one would be to wire a few modules while keeping backward compatibility without impacting any feature developer. In a matter of hours, we managed to conclude it. In a week, we had many modules using Anvil. We did not identify any expressive build time impact.</p><p>We were happy with the result. We decided to be more ambitious: we selected our code base&rsquo;s prominent monolith module to fully migrated to Anvil, and afterward, we broke this monolith apart into small libraries. It took us a few months to complete the goal, but we succeeded and did not identify any expressive build time impact, again.</p><p>To be sure we were on the right path, we mapped the relationship of a few of our most complex modules before and after adopting Anvil. For a matter of company&rsquo;s privacy, all text is blurred, but you can still see the positive impact by noting the arrows:</p><p><img src=https://dev-to-uploads.s3.amazonaws.com/i/5mwhivwsc02r0w8z8rrx.png alt="Before and After"></p><p>Finally, we decided to go full Anvil: we turned on <a href=https://github.com/square/anvil#dagger-factory-generation>Anvil&rsquo;s Dagger Factory generation</a> in all modules that we could (20+ at the time). We identified build times improvements of ~50% for individual modules build times, ~10% for Sample Apps, and because Anvil does not rely on KAPT, we never saw any KAPT issue again on those modules.</p><p><img src=https://dev-to-uploads.s3.amazonaws.com/i/pozrcji1hz1w6kn5vcj7.png alt=Benchmark></p><p>Many improvements, but we believed we could take it further: let&rsquo;s take the good things from Hilt and bring it to Anvil.</p><h1 id=hilt-to-anvil>Hilt to Anvil</h1><p>We decided to adopt what we like from Hilt while using Anvil.</p><p>The first point was to provide a single monolith component, and for that, we started to merge the components and use Anvil&rsquo;s <code>@ContributesTo</code> to binding the modules instead. It took quite some time, it was challenging but it worked well.</p><p>The second one was to support some Jetpack Libraries. We started with <code>FragmentFactory</code> to leverage the constructor injector as much as possible. We created a <code>@FragmentKey</code> and used Dagger&rsquo;s multi-binding to wire everything. Here is how the code might look like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@ContributesBinding</span>(Singleton<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>, FragmentFactory<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultibindingFragmentFactory</span> <span style=color:#a6e22e>@Inject</span> <span style=color:#66d9ef>constructor</span>(
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> map: Map&lt;Class&lt;<span style=color:#66d9ef>out</span> Fragment&gt;, <span style=color:#a6e22e>@JvmSuppressWildcards</span> Provider&lt;Fragment&gt;&gt;
) : FragmentFactory() {

    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>instantiate</span>(classLoader: ClassLoader, className: String): Fragment {
        <span style=color:#66d9ef>val</span> fragmentClass = loadFragmentClass(classLoader, className)
        <span style=color:#66d9ef>return</span> map[fragmentClass]<span style=color:#f92672>?.</span><span style=color:#66d9ef>get</span>() <span style=color:#f92672>?:</span> <span style=color:#66d9ef>super</span>.instantiate(classLoader, className)
    }
}

<span style=color:#a6e22e>@Target</span>(
    AnnotationTarget.CLASS,
    AnnotationTarget.FUNCTION
)
<span style=color:#a6e22e>@Retention</span>(value = AnnotationRetention.RUNTIME)
<span style=color:#a6e22e>@MapKey</span>
<span style=color:#66d9ef>annotation</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FragmentKey</span>(<span style=color:#66d9ef>val</span> value: KClass&lt;<span style=color:#66d9ef>out</span> Fragment&gt;)

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Activity</span> : AppCompatActivity() {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> component: MainComponent
        <span style=color:#66d9ef>get</span>() = TODO(<span style=color:#e6db74>&#34;Retrieve your Monolith Component&#34;</span>)

    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
        supportFragmentManager.fragmentFactory = component.getFragmentFactory()
        <span style=color:#66d9ef>super</span>.onCreate(savedInstanceState)
    }
}
</code></pre></div><p>And now to wire your <code>Fragment</code>, you can simple:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@ContributesMultibinding</span>(Singleton<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
<span style=color:#a6e22e>@FragmentKey</span>(HomeFragment<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeFragment</span> <span style=color:#a6e22e>@Inject</span> <span style=color:#66d9ef>constructor</span>(
    <span style=color:#75715e>// Dependencies goes here. :)
</span><span style=color:#75715e></span>) : Fragment()
</code></pre></div><p>For more details around Fragments, check the <a href=https://developer.android.com/guide/fragments>official guide</a>.</p><p>Having a Monolith Component and relying on Fragment&rsquo;s constructor injector means we can invoke any fragment from any place of our application, and things &ldquo;will work&rdquo;. Scoping becomes intuitive for those classes. If you inject an object in the <code>Fragment</code> is a fragment scope, if you inject into the <code>ViewModel</code> is a view model scope. We also offer a <code>SessionScope</code> and <code>Singleton</code> scope.</p><p>For <code>ViewModels</code> a simple <code>Provider&lt;ViewModel></code> or <code>AssistedInject</code>, if you need an instance of <code>SavedStateHandle</code>, will do the trick.</p><p>And finally, testing: Anvil offers a <a href=https://github.com/square/anvil#exclusions>replace module feature</a> that is handful to provide new dependencies during tests. For that, we create helper modules called <code>testing</code> and we provide fake dependencies of those replacing the production modules. Developers that include the <code>testing</code> in their test classpath can automatically interact with our testing utilities (or create their own, if required). To be completely honest here, it is more of an ongoing process.</p><p><img src=https://dev-to-uploads.s3.amazonaws.com/i/qy6625r4e0n4qucacvtm.png alt="General Structure"></p><h1 id=conclusion>Conclusion</h1><p>Anvil is a robust and straightforward solution. It does what it suppose to do and does it well. It benefits from a seamless synergy with Dagger, while not being opinionated and letting you decide how you integrate with other libraries (or not integrating it at all).</p><p>Also, the fact it does not rely on KAPT is a <strong>tremendous advantage</strong> for large projects and should be kept in mind while deciding between Anvil or Hilt. I&rsquo;m delighted with the overall experience, and I enjoy seeing how many feature developers started to migrate away from KAPT to Anvil proactively:</p><p><img src=https://dev-to-uploads.s3.amazonaws.com/i/g1w7vh4g3sylpkl2syyd.png alt="Kill KAPT"></p><p>Finally, as you can see above, many of the Hilt&rsquo;s features can be implemented in Anvil. However, it is vital to keep in mind Anvil is not a silver bullet. It is essential to have people in your team that understand Dagger and Dependency Injection to build the integrations you might need.</p><h1 id=update-20210225>Update 2021.02.25</h1><p>As many people reached out asking advice on how to implement some Hilt features (e.g., ViewModelScope, SavedStateHandle, and others), I created a <a href=https://github.com/marcellogalhardo/hilt-to-anvil>small showcase project</a>.</p><h1 id=update-20210319>Update 2021.03.19</h1><p>Updated <code>MultibindingFragmentFactory</code> example and <a href=https://github.com/marcellogalhardo/hilt-to-anvil>showcase project</a> to use new <code>@ContributesMultibinding</code> from <a href=https://github.com/square/anvil/releases/tag/v2.2.0>Anvil 2.2.0</a>.</p><h1 id=credits>Credits</h1><p>Thanks to <a href=https://twitter.com/maryte_chietera>Maria Chietera</a>, <a href=https://twitter.com/orafaaraujo>Rafael Araujo</a>, <a href=https://twitter.com/laggedHero>Tiago Cunha</a>, <a href=https://twitter.com/fabiocarballo>Fabio Carballo</a>, and <a href=https://twitter.com/s_anastasov>Stojan Anastasov</a> proofread review! 🔍</p><p>And a special thank you to <a href=https://twitter.com/vRallev>Ralf Wondratschek</a> for early feedback and creating Anvil! :knife:</p><p>If you like my posts, follow me on Twitter: <a href=https://twitter.com/marcellogalhard>@marcellogalhard</a></p></div><div class=post-info><div class="post-date dt-published">2021-02-05</div><a class="post-hidden-url u-url" href=http://example.org/blog/2021/02/05/n26-path-to-anvil/>http://example.org/blog/2021/02/05/n26-path-to-anvil/</a>
<a href=http://example.org/ class="p-name p-author post-hidden-author h-card" rel=me>Marcello Galhardo</a><div class=post-taxonomies></div></div></article><div class="pagination post-pagination"><div class="left pagination-item disabled"></div><div class="right pagination-item"><a href=/blog/2021/02/01/humble-views-proud-viewmodels/>Humble Views Proud ViewModels</a></div></div></main><footer class=common-footer><div class=common-footer-bottom><div class=copyright><p>© Marcello Galhardo, 2021<br>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.<br></p></div></div><p class="h-card vcard"><a href=http://example.org/ class="p-name u-url url fn" rel=me>Marcello Galhardo</a>
/
<a class="p-email u-email email" rel=me href=mailto:marcello.galhardo@gmail.com>marcello.galhardo@gmail.com</a>
<img class=u-photo src="https://avatars3.githubusercontent.com/u/4348197?s=460&v=4"></p></footer></div></body></html>