<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Naming Factory Methods | Marcello Galhardo</title>
<meta name=keywords content="android,kotlin"><meta name=description content="When discussing Factory Methods, extension functions are often preferred in Kotlin. However, naming these functions in a discoverable way without cluttering your project&rsquo;s namespace can be challenging. A great source of inspiration is Kotlin&rsquo;s Standard Library, which offers numerous examples to guide function design.
Wrapping an Instance If you want to take an existing instance and adapt it to a different object to meet another contract—such as creating a ViewModelProvider.Factory that internally uses a javax."><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Naming Factory Methods"><meta property="og:description" content="When discussing Factory Methods, extension functions are often preferred in Kotlin. However, naming these functions in a discoverable way without cluttering your project&rsquo;s namespace can be challenging. A great source of inspiration is Kotlin&rsquo;s Standard Library, which offers numerous examples to guide function design.
Wrapping an Instance If you want to take an existing instance and adapt it to a different object to meet another contract—such as creating a ViewModelProvider.Factory that internally uses a javax."><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/"><meta property="og:image" content="https://marcellogalhardo.dev/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-01T09:02:50+01:00"><meta property="article:modified_time" content="2020-02-01T09:02:50+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://marcellogalhardo.dev/logo.png"><meta name=twitter:title content="Naming Factory Methods"><meta name=twitter:description content="When discussing Factory Methods, extension functions are often preferred in Kotlin. However, naming these functions in a discoverable way without cluttering your project&rsquo;s namespace can be challenging. A great source of inspiration is Kotlin&rsquo;s Standard Library, which offers numerous examples to guide function design.
Wrapping an Instance If you want to take an existing instance and adapt it to a different object to meet another contract—such as creating a ViewModelProvider.Factory that internally uses a javax."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Naming Factory Methods","item":"https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Naming Factory Methods","name":"Naming Factory Methods","description":"When discussing Factory Methods, extension functions are often preferred in Kotlin. However, naming these functions in a discoverable way without cluttering your project\u0026rsquo;s namespace can be challenging. A great source of inspiration is Kotlin\u0026rsquo;s Standard Library, which offers numerous examples to guide function design.\nWrapping an Instance If you want to take an existing instance and adapt it to a different object to meet another contract—such as creating a ViewModelProvider.Factory that internally uses a javax.","keywords":["android","kotlin"],"articleBody":"When discussing Factory Methods, extension functions are often preferred in Kotlin. However, naming these functions in a discoverable way without cluttering your project’s namespace can be challenging. A great source of inspiration is Kotlin’s Standard Library, which offers numerous examples to guide function design.\nWrapping an Instance If you want to take an existing instance and adapt it to a different object to meet another contract—such as creating a ViewModelProvider.Factory that internally uses a javax.inject.Provider—you’ll need a wrapper. An example from Kotlin’s Standard Library is asExecutor, which performs a similar role.\nHere’s an example of how such a wrapper could look:\nfun \u003cVM : ViewModel\u003e Provider\u003cout VM\u003e.asViewModelProviderFactory(): ViewModelProvider.Factory { return object : ViewModelProvider.Factory { override fun \u003cT : ViewModel?\u003e create(modelClass: Class): T { @Suppress(\"UNCHECKED_CAST\") return get() as T } } } Mapping Data When you need to transform an instance by copying its data into a different format—like converting a UserResponse (DTO) into a User (domain entity) — a mapper is the right tool. Kotlin’s Standard Library provides a great example with toList.\nfun UserDto.toUser(): User { return User( name = Name( first = this.firstName, last = this.lastName ), email = Email(this.email), age = this.age ) } Vararg Constructors If you need a secondary constructor that accepts an unknown number of elements, use a collection wrapper. A vararg method allows you to create a new object without overloading your class definition. Kotlin’s Standard Library provides the listOf function as an example.\nfun controllerOf(vararg controllers: Controller): Controller { return CompositeController(controllers) } Builders Kotlin’s constructors combined with named parameters cover most use cases for the Builder Design Pattern. However, when creating instances with many optional parameters or highly configurable attributes, builders become necessary. The buildString function is a good reference.\ninline fun buildImageLoader( builderAction: ImageLoaderBuilder.() -\u003e Unit ): String data class ImageLoaderBuilder( var uri: URI, @DrawableRes var loadingPlaceholder: Int?, @DrawableRes var errorPlaceholder: Int? // ... ) // Usage example fun main() { val imageLoader = buildImageLoader { uri = validUri loadingPlaceholder = R.drawable.loading_placeholder errorPlaceholder = R.drawable.error_placeholder // ... } } Fake Constructors (Factory Methods) Sometimes, you need a secondary constructor that leverages reified types or provides a concrete type while exposing an interface. In such cases, a function named after the class serves as a Factory Method. Consider this example from MutableStateFlow.\ninterface MutableStateFlow { var value: T fun compareAndSet(expect: T, update: T): Boolean } fun \u003cT\u003e MutableStateFlow(value: T): MutableStateFlow { return StateFlowImpl(value ?: NULL) } Conclusion As demonstrated, Kotlin’s Standard Library is an excellent resource for designing code that enhances discoverability for Kotlin developers. Kotlin’s consistency can be a powerful advantage — why not leverage it?\nℹ️ If you enjoyed the article you might enjoy following me on Bluesky. ℹ️\n","wordCount":"449","inLanguage":"en","image":"https://marcellogalhardo.dev/logo.png","datePublished":"2020-02-01T09:02:50+01:00","dateModified":"2020-02-01T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2020/02/01/naming-factory-methods/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Naming Factory Methods</h1><div class=post-meta><span title='2020-02-01 09:02:50 +0100 +0100'>February 1, 2020</span></div></header><div class=post-content><p>When discussing Factory Methods, extension functions are often preferred in Kotlin. However, naming these functions in a discoverable way without cluttering your project&rsquo;s namespace can be challenging. A great source of inspiration is Kotlin&rsquo;s Standard Library, which offers numerous examples to guide function design.</p><h2 id=wrapping-an-instance>Wrapping an Instance<a hidden class=anchor aria-hidden=true href=#wrapping-an-instance>#</a></h2><p>If you want to take an existing instance and adapt it to a different object to meet another contract—such as creating a <code>ViewModelProvider.Factory</code> that internally uses a <code>javax.inject.Provider</code>—you’ll need a wrapper. An example from Kotlin&rsquo;s Standard Library is <a href=https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-executor.html>asExecutor</a>, which performs a similar role.</p><p>Here’s an example of how such a wrapper could look:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>VM</span> : <span style=color:#a6e22e>ViewModel</span>&gt; <span style=color:#a6e22e>Provider</span>&lt;<span style=color:#66d9ef>out</span> VM&gt;.asViewModelProviderFactory(): <span style=color:#a6e22e>ViewModelProvider</span>.Factory {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>ViewModelProvider</span>.Factory {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span> : <span style=color:#a6e22e>ViewModel</span>?&gt; <span style=color:#a6e22e>create</span>(modelClass: Class&lt;T&gt;): T {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Suppress</span>(<span style=color:#e6db74>&#34;UNCHECKED_CAST&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>() <span style=color:#66d9ef>as</span> T
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=mapping-data>Mapping Data<a hidden class=anchor aria-hidden=true href=#mapping-data>#</a></h2><p>When you need to transform an instance by copying its data into a different format—like converting a <code>UserResponse</code> (DTO) into a <code>User</code> (domain entity) — a mapper is the right tool. Kotlin&rsquo;s Standard Library provides a great example with <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/to-list.html>toList</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>UserDto</span>.toUser(): User {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> User(
</span></span><span style=display:flex><span>        name = Name(
</span></span><span style=display:flex><span>            first = <span style=color:#66d9ef>this</span>.firstName,
</span></span><span style=display:flex><span>            last = <span style=color:#66d9ef>this</span>.lastName
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        email = Email(<span style=color:#66d9ef>this</span>.email),
</span></span><span style=display:flex><span>        age = <span style=color:#66d9ef>this</span>.age
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=vararg-constructors>Vararg Constructors<a hidden class=anchor aria-hidden=true href=#vararg-constructors>#</a></h2><p>If you need a secondary constructor that accepts an unknown number of elements, use a collection wrapper. A <code>vararg</code> method allows you to create a new object without overloading your class definition. Kotlin&rsquo;s Standard Library provides the <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html>listOf</a> function as an example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>controllerOf</span>(<span style=color:#66d9ef>vararg</span> controllers: Controller): Controller {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> CompositeController(controllers)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=builders>Builders<a hidden class=anchor aria-hidden=true href=#builders>#</a></h2><p>Kotlin’s constructors combined with named parameters cover most use cases for the Builder Design Pattern. However, when creating instances with many optional parameters or highly configurable attributes, builders become necessary. The <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/build-string.html>buildString</a> function is a good reference.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>buildImageLoader</span>(
</span></span><span style=display:flex><span>    builderAction: <span style=color:#a6e22e>ImageLoaderBuilder</span>.() <span style=color:#f92672>-&gt;</span> Unit
</span></span><span style=display:flex><span>): String
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ImageLoaderBuilder</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> uri: URI,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@DrawableRes</span> <span style=color:#66d9ef>var</span> loadingPlaceholder: Int?,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@DrawableRes</span> <span style=color:#66d9ef>var</span> errorPlaceholder: Int?
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Usage example
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> imageLoader = buildImageLoader {
</span></span><span style=display:flex><span>        uri = validUri
</span></span><span style=display:flex><span>        loadingPlaceholder = <span style=color:#a6e22e>R</span>.drawable.loading_placeholder
</span></span><span style=display:flex><span>        errorPlaceholder = <span style=color:#a6e22e>R</span>.drawable.error_placeholder
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fake-constructors-factory-methods>Fake Constructors (Factory Methods)<a hidden class=anchor aria-hidden=true href=#fake-constructors-factory-methods>#</a></h2><p>Sometimes, you need a secondary constructor that leverages <code>reified</code> types or provides a concrete type while exposing an interface. In such cases, a function named after the class serves as a Factory Method. Consider this example from <a href=https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/flow/StateFlow.kt#L187>MutableStateFlow</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MutableStateFlow</span>&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> value: T
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>compareAndSet</span>(<span style=color:#66d9ef>expect</span>: T, update: T): Boolean
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span>&gt; <span style=color:#a6e22e>MutableStateFlow</span>(<span style=color:#66d9ef>value</span>: T): MutableStateFlow&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> StateFlowImpl(<span style=color:#66d9ef>value</span> <span style=color:#f92672>?:</span> NULL)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>As demonstrated, Kotlin’s Standard Library is an excellent resource for designing code that enhances discoverability for Kotlin developers. Kotlin’s consistency can be a powerful advantage — why not leverage it?</p><hr><blockquote><p>ℹ️ If you enjoyed the article you might enjoy following me on <a href=https://bsky.app/profile/marcellogalhardo.dev>Bluesky</a>. ℹ️</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/android/>Android</a></li><li><a href=https://marcellogalhardo.dev/tags/kotlin/>Kotlin</a></li></ul></footer></article></main><footer class=footer><span>CC BY-NC 4.0</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>