<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Namespace for Extension Functions | Marcello Galhardo</title>
<meta name=keywords content="kotlin"><meta name=description content="A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn&rsquo;t support package-private, yet."><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Namespace for Extension Functions"><meta property="og:description" content="A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn&rsquo;t support package-private, yet."><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"><meta property="og:image" content="https://marcellogalhardo.dev/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-25T09:02:50+01:00"><meta property="article:modified_time" content="2023-03-25T09:02:50+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://marcellogalhardo.dev/logo.png"><meta name=twitter:title content="Namespace for Extension Functions"><meta name=twitter:description content="A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn&rsquo;t support package-private, yet."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Namespace for Extension Functions","item":"https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Namespace for Extension Functions","name":"Namespace for Extension Functions","description":"A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:\nThe receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn\u0026rsquo;t support package-private, yet.","keywords":["kotlin"],"articleBody":"A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:\nThe receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn‚Äôt support package-private, yet. So how can I have the advantages of using extension functions but avoid these issues?\nOne way is to use objects as namespace for extension functions.\nHere is an example:\n// feature/MyFeatureActivityManagers.kt // Namespace object. internal object MyFeatureActivityManagers { // Extension functions that are only interested to my feature. fun ActivityManager.doSomethingThatOnlyYouCare() = TODO(\"\") fun ActivityManager.doSomethingThatOnlyYouCareToo() = TODO(\"\") } And here is the usage:\n// feature/MyFeature.kt import MyFeatureActivityManagers.doSomethingThatOnlyYouCare fun myFeature(activityManager: ActivityManager) { activityManager.doSomethingThatOnlyYouCare() } It didn‚Äôt change much but the approach has a few advantages:\nIt ensures that code in the same package can only access the extension function with a direct import; It helps humans, and tools, to identify what file the extension is coming from; But most important, it has the right level of discoverability*. What I mean with discoverability is that IntelliJ IDEA seems to have a hierarchy for suggesting auto-complete in the following order:\nMember functions Global extensions Object extensions Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.\nWhat‚Äôs up with the naming? I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.\nA pattern I find useful is: {Context}{Receiver}s, where:\nContext groups the functions based on their relevance. Receiver refers to the type of the receiver for these functions. s represents the collection of extensions. Wrapping up If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them. That will help your project with organization and readability.\nCredits Special thanks to Maria Chietera, and Jacob Rein proofread review! üîç\n‚ÑπÔ∏è To stay up to date with my writing, follow me on Twitter or Mastodon. If you have any questions or I missed something, feel free to reach out to me! ‚ÑπÔ∏è\n","wordCount":"374","inLanguage":"en","image":"https://marcellogalhardo.dev/logo.png","datePublished":"2023-03-25T09:02:50+01:00","dateModified":"2023-03-25T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Namespace for Extension Functions</h1><div class=post-meta><span title='2023-03-25 09:02:50 +0100 +0100'>March 25, 2023</span></div></header><div class=post-content><p>A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:</p><ul><li>The receiver was a common type, polluted with too many methods.</li><li>The extension function was only relevant to my feature package.</li><li>Creating a <del>Gradle</del> module was out of scope.</li><li>Introducing a new type to hold the function felt like too much.</li><li><a href=https://youtrack.jetbrains.com/issue/KT-29227/Provide-package-private-visibility-modifier-or-another-scope-reducing-mechanism>Kotlin doesn&rsquo;t support package-private</a>, yet.</li></ul><p>So how can I have the advantages of using extension functions but avoid these issues?</p><p>One way is to use objects as namespace for extension functions.</p><p>Here is an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// feature/MyFeatureActivityManagers.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Namespace object.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>MyFeatureActivityManagers</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Extension functions that are only interested to my feature.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingThatOnlyYouCare() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingThatOnlyYouCareToo() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here is the usage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// feature/MyFeature.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> MyFeatureActivityManagers.doSomethingThatOnlyYouCare
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>myFeature</span>(activityManager: ActivityManager) {
</span></span><span style=display:flex><span>    activityManager.doSomethingThatOnlyYouCare()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It didn&rsquo;t change much but the approach has a few advantages:</p><ul><li>It ensures that code in the same package can only access the extension function with a direct import;</li><li>It helps humans, and tools, to identify what file the extension is coming from;</li><li>But most important, it has the right level of discoverability*.</li></ul><p>What I mean with discoverability is that IntelliJ IDEA seems to have a hierarchy for suggesting auto-complete in the following order:</p><ul><li>Member functions</li><li>Global extensions</li><li>Object extensions</li></ul><p>Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.</p><h2 id=whats-up-with-the-naming>What&rsquo;s up with the naming?<a hidden class=anchor aria-hidden=true href=#whats-up-with-the-naming>#</a></h2><p>I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.</p><p>A pattern I find useful is: <code>{Context}{Receiver}s</code>, where:</p><ul><li><code>Context</code> groups the functions based on their relevance.</li><li><code>Receiver</code> refers to the type of the receiver for these functions.</li><li><code>s</code> represents the collection of extensions.</li></ul><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them. That will help your project with organization and readability.</p><h1 id=credits>Credits<a hidden class=anchor aria-hidden=true href=#credits>#</a></h1><p>Special thanks to <a href=https://twitter.com/mchietera>Maria Chietera</a>, and <a href=https://twitter.com/deathssouls>Jacob Rein</a> proofread review! üîç</p><hr><blockquote><p>‚ÑπÔ∏è To stay up to date with my writing, follow me on <a href=https://twitter.com/marcellogalhard>Twitter</a> or <a href=http://androiddev.social/@mg>Mastodon</a>. If you have any questions or I missed something, feel free to reach out to me! ‚ÑπÔ∏è</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/kotlin/>Kotlin</a></li></ul></footer></article></main><footer class=footer><span>CC BY-NC 4.0</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>