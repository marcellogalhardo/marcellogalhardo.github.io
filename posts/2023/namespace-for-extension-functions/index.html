<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Namespace for Extension Functions | Marcello Galhardo</title><meta name=keywords content="kotlin"><meta name=description content="A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:
 The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn&rsquo;t support package-private, yet."><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Namespace for Extension Functions"><meta property="og:description" content="A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:
 The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn&rsquo;t support package-private, yet."><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-25T09:02:50+01:00"><meta property="article:modified_time" content="2023-03-25T09:02:50+01:00"><meta property="og:site_name" content="Marcello Galhardo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Namespace for Extension Functions"><meta name=twitter:description content="A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:
 The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn&rsquo;t support package-private, yet."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Namespace for Extension Functions","item":"https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Namespace for Extension Functions","name":"Namespace for Extension Functions","description":"A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:\n The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn\u0026rsquo;t support package-private, yet.","keywords":["kotlin"],"articleBody":"A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:\n The receiver was a common type, polluted with too many methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Kotlin doesn‚Äôt support package-private, yet.  So how can I have the advantages of using extension functions but avoid these issues?\nOne way is to use objects as namespace for extension functions.\nHere is an example:\n// feature/MyFeatureActivityManagers.kt  // Namespace object. internal object MyFeatureActivityManagers {   // Extension functions that are only interested to my feature.  fun ActivityManager.doSomethingThatOnlyYouCare() = TODO(\"\")  fun ActivityManager.doSomethingThatOnlyYouCareToo() = TODO(\"\") } And here is the usage:\n// feature/MyFeature.kt  import MyFeatureActivityManagers.doSomethingThatOnlyYouCare  fun myFeature(activityManager: ActivityManager) {  activityManager.doSomethingThatOnlyYouCare() } It didn‚Äôt change much but the approach has a few advantages:\n It ensures that code in the same package can only access the extension function with a direct import; It helps humans, and tools, to identify what file the extension is coming from; But most important, it has the right level of discoverability*.  What I mean with discoverability is that IntelliJ IDEA seems to have a hierarchy for suggesting auto-complete in the following order:\n Member functions Global extensions Object extensions  Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.\nWhat‚Äôs up with the naming? I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.\nA pattern I find useful is: {Context}{Receiver}s, where:\n Context groups the functions based on their relevance. Receiver refers to the type of the receiver for these functions. s represents the collection of extensions.  Wrapping up If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them. That will help your project with organization and readability.\nCredits Special thanks to Maria Chietera, and Jacob Rein proofread review! üîç\n  ‚ÑπÔ∏è To stay up to date with my writing, follow me on Twitter or Mastodon. If you have any questions or I missed something, feel free to reach out to me! ‚ÑπÔ∏è\n ","wordCount":"374","inLanguage":"en","datePublished":"2023-03-25T09:02:50+01:00","dateModified":"2023-03-25T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Namespace for Extension Functions</h1><div class=post-meta><span title="2023-03-25 09:02:50 +0100 +0100">March 25, 2023</span></div></header><div class=post-content><p>A few weeks ago, I had to create an extension function - a usual task for any Kotlin developer. But there were a few limitations:</p><ul><li>The receiver was a common type, polluted with too many methods.</li><li>The extension function was only relevant to my feature package.</li><li>Creating a <del>Gradle</del> module was out of scope.</li><li>Introducing a new type to hold the function felt like too much.</li><li><a href=https://youtrack.jetbrains.com/issue/KT-29227/Provide-package-private-visibility-modifier-or-another-scope-reducing-mechanism>Kotlin doesn&rsquo;t support package-private</a>, yet.</li></ul><p>So how can I have the advantages of using extension functions but avoid these issues?</p><p>One way is to use objects as namespace for extension functions.</p><p>Here is an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// feature/MyFeatureActivityManagers.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Namespace object.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>MyFeatureActivityManagers</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Extension functions that are only interested to my feature.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingThatOnlyYouCare() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingThatOnlyYouCareToo() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here is the usage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// feature/MyFeature.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> MyFeatureActivityManagers.doSomethingThatOnlyYouCare
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>myFeature</span>(activityManager: ActivityManager) {
</span></span><span style=display:flex><span>    activityManager.doSomethingThatOnlyYouCare()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It didn&rsquo;t change much but the approach has a few advantages:</p><ul><li>It ensures that code in the same package can only access the extension function with a direct import;</li><li>It helps humans, and tools, to identify what file the extension is coming from;</li><li>But most important, it has the right level of discoverability*.</li></ul><p>What I mean with discoverability is that IntelliJ IDEA seems to have a hierarchy for suggesting auto-complete in the following order:</p><ul><li>Member functions</li><li>Global extensions</li><li>Object extensions</li></ul><p>Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.</p><h2 id=whats-up-with-the-naming>What&rsquo;s up with the naming?<a hidden class=anchor aria-hidden=true href=#whats-up-with-the-naming>#</a></h2><p>I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.</p><p>A pattern I find useful is: <code>{Context}{Receiver}s</code>, where:</p><ul><li><code>Context</code> groups the functions based on their relevance.</li><li><code>Receiver</code> refers to the type of the receiver for these functions.</li><li><code>s</code> represents the collection of extensions.</li></ul><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them. That will help your project with organization and readability.</p><h1 id=credits>Credits<a hidden class=anchor aria-hidden=true href=#credits>#</a></h1><p>Special thanks to <a href=https://twitter.com/maryte_chietera>Maria Chietera</a>, and <a href=https://twitter.com/deathssouls>Jacob Rein</a> proofread review! üîç</p><hr><blockquote><p>‚ÑπÔ∏è To stay up to date with my writing, follow me on <a href=https://twitter.com/marcellogalhard>Twitter</a> or <a href=http://androiddev.social/@mg>Mastodon</a>. If you have any questions or I missed something, feel free to reach out to me! ‚ÑπÔ∏è</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/kotlin/>kotlin</a></li></ul></footer></article></main><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://marcellogalhardo.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></body></html>