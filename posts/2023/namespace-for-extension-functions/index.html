<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Namespace for Extension Functions | Marcello Galhardo</title><meta name=keywords content="kotlin"><meta name=description content="A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?"><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Namespace for Extension Functions"><meta property="og:description" content="A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?"><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-25T09:02:50+01:00"><meta property="article:modified_time" content="2023-03-25T09:02:50+01:00"><meta property="og:site_name" content="Marcello Galhardo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Namespace for Extension Functions"><meta name=twitter:description content="A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Namespace for Extension Functions","item":"https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Namespace for Extension Functions","name":"Namespace for Extension Functions","description":"A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:\nThe receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?","keywords":["kotlin"],"articleBody":"A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:\nThe receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Introducing a new type to hold the function felt like too much. Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?\nOne way is to use objects as namespace for extension functions.\nHere is an example:\n// feature/MyFeatureActivityManagers.kt // Namespace object. object MyFeatureActivityManagers { // Extension functions that are only interested to my feature. fun ActivityManager.doSomethingThatOnlyYouCare() = TODO(\"\") fun ActivityManager.doSomethingThatOnlyYouCareToo() = TODO(\"\") } And here is the usage:\n// feature/MyFeature.kt import MyFeatureActivityManagers.doSomethingThatOnlyYouCare fun myFeature(activityManager: ActivityManager) { activityManager.doSomethingThatOnlyYouCare() } It didn’t change much but the approach has a few advantages:\nIt ensures that code in the same package can only access the extension function with a direct import; It helps humans (and tools) to identify what file the extension is coming from; But most important, it has the right level of discoverability*. *: IntelliJ IDEA has a hierarchy for suggesting auto-complete in the following order:\nMember functions Global extensions Object extensions Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.\nWhat’s up with the naming?\nI want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.\nA pattern I find useful is: {Context}{Receiver}s, where:\nContext groups the functions based on their relevance. Receiver refers to the type of the receiver for these functions. s represents the collection of extensions. If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them.\nℹ️ To stay up to date with my writing, follow me on Twitter or Mastodon. If you have any questions or I missed something, feel free to reach out to me! ℹ️\n","wordCount":"343","inLanguage":"en","datePublished":"2023-03-25T09:02:50+01:00","dateModified":"2023-03-25T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2023/namespace-for-extension-functions/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Namespace for Extension Functions</h1><div class=post-meta><span title='2023-03-25 09:02:50 +0100 +0100'>March 25, 2023</span></div></header><div class=post-content><p>A few weeks ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few limitations:</p><ul><li>The receiver was a common type, polluted with methods.</li><li>The extension function was only relevant to my feature package.</li><li>Creating a <del>Gradle</del> module was out of scope.</li><li>Introducing a new type to hold the function felt like too much.</li></ul><p>Trying to be a good citizen, I asked myself: how can I have the advantages of using extension functions but avoid these issues?</p><p>One way is to use objects as namespace for extension functions.</p><p>Here is an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// feature/MyFeatureActivityManagers.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Namespace object.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>MyFeatureActivityManagers</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Extension functions that are only interested to my feature.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingThatOnlyYouCare() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingThatOnlyYouCareToo() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here is the usage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// feature/MyFeature.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> MyFeatureActivityManagers.doSomethingThatOnlyYouCare
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>myFeature</span>(activityManager: ActivityManager) {
</span></span><span style=display:flex><span>    activityManager.doSomethingThatOnlyYouCare()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It didn&rsquo;t change much but the approach has a few advantages:</p><ul><li>It ensures that code in the same package can only access the extension function with a direct import;</li><li>It helps humans (and tools) to identify what file the extension is coming from;</li><li>But most important, it has the right level of discoverability*.</li></ul><p>*: IntelliJ IDEA has a hierarchy for suggesting auto-complete in the following order:</p><ul><li>Member functions</li><li>Global extensions</li><li>Object extensions</li></ul><p>Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.</p><hr><p><strong>What&rsquo;s up with the naming?</strong></p><p>I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.</p><p>A pattern I find useful is: {Context}{Receiver}s, where:</p><ul><li><code>Context</code> groups the functions based on their relevance.</li><li><code>Receiver</code> refers to the type of the receiver for these functions.</li><li><code>s</code> represents the collection of extensions.</li></ul><hr><p>If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them.</p><blockquote><p>ℹ️ To stay up to date with my writing, follow me on <a href=https://twitter.com/marcellogalhard>Twitter</a> or <a href=http://androiddev.social/@mg>Mastodon</a>. If you have any questions or I missed something, feel free to reach out to me! ℹ️</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/kotlin/>kotlin</a></li></ul></footer></article></main><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://marcellogalhardo.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></body></html>