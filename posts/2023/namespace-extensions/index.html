<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Namespace Extensions | Marcello Galhardo</title><meta name=keywords content="kotlin"><meta name=description content="A few days ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few problems:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Trying to be a good citizen, I asked myself (not literally): how can I have the advantages of using extension functions but avoid these issues?"><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2023/namespace-extensions/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Namespace Extensions"><meta property="og:description" content="A few days ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few problems:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Trying to be a good citizen, I asked myself (not literally): how can I have the advantages of using extension functions but avoid these issues?"><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2023/namespace-extensions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-25T09:02:50+01:00"><meta property="article:modified_time" content="2023-03-25T09:02:50+01:00"><meta property="og:site_name" content="Marcello Galhardo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Namespace Extensions"><meta name=twitter:description content="A few days ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few problems:
The receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Trying to be a good citizen, I asked myself (not literally): how can I have the advantages of using extension functions but avoid these issues?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Namespace Extensions","item":"https://marcellogalhardo.dev/posts/2023/namespace-extensions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Namespace Extensions","name":"Namespace Extensions","description":"A few days ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few problems:\nThe receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Trying to be a good citizen, I asked myself (not literally): how can I have the advantages of using extension functions but avoid these issues?","keywords":["kotlin"],"articleBody":"A few days ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few problems:\nThe receiver was a common type, polluted with methods. The extension function was only relevant to my feature package. Creating a Gradle module was out of scope. Trying to be a good citizen, I asked myself (not literally): how can I have the advantages of using extension functions but avoid these issues?\nOne way is to use objects to namespace extension functions.\n// Namespace object. object MyFeatureActivityManagers { // Extensions functions that are not interested to everyone. fun ActivityManager.doSomethingButOnlyYouCare() = TODO(\"\") fun ActivityManager.doSomethingButOnlyYouCareToo() = TODO(\"\") } The approach has the following advantages:\nIt ensures that code in the same package can only access the extension function with a direct import; It helps humans (and tools) to identify where the extension is coming from; But most important, it has the right level of discoverability*. Discoverability? What do you mean?\nIt seems IDEA has a clear hierarchy for suggesting auto-complete in the following order:\nMember functions Global extensions Object extensions Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.\nBut what about how you named your namespace object?\nIdeally, I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.\nA pattern I find helpful is: {Context}{Receiver}s, where:\nContext groups the functions based on their relevance. Receiver refers to the type of the receiver for these functions. s represents the collection of extensions. If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them.\n:bell: To stay up to date with my writing, follow me on Mastodon or Twitter. If you have any questions, feel free to reach me out!\n","wordCount":"309","inLanguage":"en","datePublished":"2023-03-25T09:02:50+01:00","dateModified":"2023-03-25T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2023/namespace-extensions/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Namespace Extensions</h1><div class=post-meta><span title='2023-03-25 09:02:50 +0100 +0100'>March 25, 2023</span></div></header><div class=post-content><p>A few days ago, I had to create an extension function - a prevalent task for any Kotlin developer. But there were a few problems:</p><ul><li>The receiver was a common type, polluted with methods.</li><li>The extension function was only relevant to my feature package.</li><li>Creating a Gradle module was out of scope.</li></ul><p>Trying to be a good citizen, I asked myself (not literally): how can I have the advantages of using extension functions but avoid these issues?</p><p>One way is to use objects to namespace extension functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// Namespace object.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>MyFeatureActivityManagers</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Extensions functions that are not interested to everyone.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingButOnlyYouCare() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ActivityManager</span>.doSomethingButOnlyYouCareToo() = TODO(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The approach has the following advantages:</p><ul><li>It ensures that code in the same package can only access the extension function with a direct import;</li><li>It helps humans (and tools) to identify where the extension is coming from;</li><li>But most important, it has the right level of discoverability*.</li></ul><p>Discoverability? What do you mean?</p><p>It seems IDEA has a clear hierarchy for suggesting auto-complete in the following order:</p><ul><li>Member functions</li><li>Global extensions</li><li>Object extensions</li></ul><p>Hence, IDEA will only suggest to other developers your shiny function if they are actively looking for it.</p><hr><p><strong>But what about how you named your namespace object?</strong></p><p>Ideally, I want to indicate why these particular functions are related, given the infinite number of possible extensions I could write.</p><p>A pattern I find helpful is: {Context}{Receiver}s, where:</p><ul><li><code>Context</code> groups the functions based on their relevance.</li><li><code>Receiver</code> refers to the type of the receiver for these functions.</li><li><code>s</code> represents the collection of extensions.</li></ul><hr><p>If you find yourself creating extensions that should be limited in access, consider creating a namespace object for them.</p><blockquote><p>:bell: To stay up to date with my writing, follow me on <a href=http://androiddev.social/@mg>Mastodon</a> or <a href=https://twitter.com/marcellogalhard>Twitter</a>. If you have any questions, feel free to reach me out!</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/kotlin/>kotlin</a></li></ul></footer></article></main><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://marcellogalhardo.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></body></html>