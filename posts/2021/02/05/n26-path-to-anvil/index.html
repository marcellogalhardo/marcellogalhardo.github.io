<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>N26 Path to Anvil | Marcello Galhardo</title><meta name=keywords content="android,dagger,anvil"><meta name=description content="This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.
N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;Sample Apps&rdquo; for years now as our full app build time might take up to 20 minutes."><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2021/02/05/n26-path-to-anvil/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="N26 Path to Anvil"><meta property="og:description" content="This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.
N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;Sample Apps&rdquo; for years now as our full app build time might take up to 20 minutes."><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2021/02/05/n26-path-to-anvil/"><meta property="og:image" content="https://marcellogalhardo.dev/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-05T09:02:50+01:00"><meta property="article:modified_time" content="2021-02-05T09:02:50+01:00"><meta property="og:site_name" content="Marcello Galhardo"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://marcellogalhardo.dev/logo.png"><meta name=twitter:title content="N26 Path to Anvil"><meta name=twitter:description content="This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.
N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;Sample Apps&rdquo; for years now as our full app build time might take up to 20 minutes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"N26 Path to Anvil","item":"https://marcellogalhardo.dev/posts/2021/02/05/n26-path-to-anvil/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"N26 Path to Anvil","name":"N26 Path to Anvil","description":"This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.\nN26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using \u0026ldquo;Sample Apps\u0026rdquo; for years now as our full app build time might take up to 20 minutes.","keywords":["android","dagger","anvil"],"articleBody":"This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.\nN26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using “Sample Apps” for years now as our full app build time might take up to 20 minutes.\nToday I will share a little about my story with Dagger inside the company, why we adopt Anvil, some of the challenges we faced, and how are the results so far.\nDagger, (oh, my) N26 has a long history with Dagger. We have been using it for years, we developed our customizations and libraries on top of it, and many of our architectural decisions were made relying on Dagger features.\nDagger is excellent but comes with a price when used with Kotlin. The more we grew, the more we were charged. Stub generation issues, slow build time, increasing boilerplate to wire @dagger.Component, new joiners avoided touching the graphs due to complexity…\nLooking for solutions, we found Hilt by Google. We enjoyed many of the ideas they proposed as the Monolithic Component and the testing philosophy. But the trade-off was not that good for us: a migration would be painful and would take months to years, to not say we did not appreciate the byte code manipulation and the extra KAPT processor.\nSimultaneously, another solution appeared, which solved some of the same problems differently: Anvil.\n Anvil is a Kotlin compiler plugin to make dependency injection with Dagger easier by automatically merging Dagger modules and component interfaces.\n Sharpening your blade To get an idea of how Anvil would affect us, we started with a set of experiments. The first one would be to wire a few modules while keeping backward compatibility without impacting any feature developer. In a matter of hours, we managed to conclude it. In a week, we had many modules using Anvil. We did not identify any expressive build time impact.\nWe were happy with the result. We decided to be more ambitious: we selected our code base’s prominent monolith module to fully migrated to Anvil, and afterward, we broke this monolith apart into small libraries. It took us a few months to complete the goal, but we succeeded and did not identify any expressive build time impact, again.\nTo be sure we were on the right path, we mapped the relationship of a few of our most complex modules before and after adopting Anvil. For a matter of company’s privacy, all text is blurred, but you can still see the positive impact by noting the arrows:\nFinally, we decided to go full Anvil: we turned on Anvil’s Dagger Factory generation in all modules that we could (20+ at the time). We identified build times improvements of ~50% for individual modules build times, ~10% for Sample Apps, and because Anvil does not rely on KAPT, we never saw any KAPT issue again on those modules.\nMany improvements, but we believed we could take it further: let’s take the good things from Hilt and bring it to Anvil.\nHilt to Anvil We decided to adopt what we like from Hilt while using Anvil.\nThe first point was to provide a single monolith component, and for that, we started to merge the components and use Anvil’s @ContributesTo to binding the modules instead. It took quite some time, it was challenging but it worked well.\nThe second one was to support some Jetpack Libraries. We started with FragmentFactory to leverage the constructor injector as much as possible. We created a @FragmentKey and used Dagger’s multi-binding to wire everything. Here is how the code might look like:\n@ContributesBinding(Singleton::class, FragmentFactory::class) class MultibindingFragmentFactory @Inject constructor(  private val map: Mapout Fragment, @JvmSuppressWildcards Provider ) : FragmentFactory() {   override fun instantiate(classLoader: ClassLoader, className: String): Fragment {  val fragmentClass = loadFragmentClass(classLoader, className)  return map[fragmentClass]?.get() ?: super.instantiate(classLoader, className)  } }  @Target(  AnnotationTarget.CLASS,  AnnotationTarget.FUNCTION ) @Retention(value = AnnotationRetention.RUNTIME) @MapKey annotation class FragmentKey(val value: KClassout Fragment)  class Activity : AppCompatActivity() {   private val component: MainComponent  get() = TODO(\"Retrieve your Monolith Component\")   override fun onCreate(savedInstanceState: Bundle?) {  supportFragmentManager.fragmentFactory = component.getFragmentFactory()  super.onCreate(savedInstanceState)  } } And now to wire your Fragment, you can simple:\n@ContributesMultibinding(Singleton::class) @FragmentKey(HomeFragment::class) class HomeFragment @Inject constructor(  // Dependencies goes here. :) ) : Fragment() For more details around Fragments, check the official guide.\nHaving a Monolith Component and relying on Fragment’s constructor injector means we can invoke any fragment from any place of our application, and things “will work”. Scoping becomes intuitive for those classes. If you inject an object in the Fragment is a fragment scope, if you inject into the ViewModel is a view model scope. We also offer a SessionScope and Singleton scope.\nFor ViewModels a simple Provider or AssistedInject, if you need an instance of SavedStateHandle, will do the trick.\nAnd finally, testing: Anvil offers a replace module feature that is handful to provide new dependencies during tests. For that, we create helper modules called testing and we provide fake dependencies of those replacing the production modules. Developers that include the testing in their test classpath can automatically interact with our testing utilities (or create their own, if required). To be completely honest here, it is more of an ongoing process.\nConclusion Anvil is a robust and straightforward solution. It does what it suppose to do and does it well. It benefits from a seamless synergy with Dagger, while not being opinionated and letting you decide how you integrate with other libraries (or not integrating it at all).\nAlso, the fact it does not rely on KAPT is a tremendous advantage for large projects and should be kept in mind while deciding between Anvil or Hilt. I’m delighted with the overall experience, and I enjoy seeing how many feature developers started to migrate away from KAPT to Anvil proactively:\nFinally, as you can see above, many of the Hilt’s features can be implemented in Anvil. However, it is vital to keep in mind Anvil is not a silver bullet. It is essential to have people in your team that understand Dagger and Dependency Injection to build the integrations you might need.\nUpdate 2021.02.25 As many people reached out asking advice on how to implement some Hilt features (e.g., ViewModelScope, SavedStateHandle, and others), I created a small showcase project.\nUpdate 2021.03.19 Updated MultibindingFragmentFactory example and showcase project to use new @ContributesMultibinding from Anvil 2.2.0.\nCredits Thanks to Maria Chietera, Rafael Araujo, Tiago Cunha, Fabio Carballo, and Stojan Anastasov proofread review! 🔍\nAnd a special thank you to Ralf Wondratschek for early feedback and creating Anvil! :knife:\n  ℹ️ To stay up to date with my writing, follow me on Twitter or Mastodon. If you have any questions or I missed something, feel free to reach out to me! ℹ️\n ","wordCount":"1150","inLanguage":"en","datePublished":"2021-02-05T09:02:50+01:00","dateModified":"2021-02-05T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2021/02/05/n26-path-to-anvil/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>N26 Path to Anvil</h1><div class=post-meta><span title="2021-02-05 09:02:50 +0100 +0100">February 5, 2021</span></div></header><div class=post-content><p>This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.</p><p>N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &ldquo;<a href=https://cashapp.github.io/2020-08-25/attacking-build-times-with-sample-apps>Sample Apps</a>&rdquo; for years now as our full app build time might take up to 20 minutes.</p><p>Today I will share a little about my story with Dagger inside the company, why we adopt Anvil, some of the challenges we faced, and how are the results so far.</p><h1 id=dagger-oh-my>Dagger, (oh, my)<a hidden class=anchor aria-hidden=true href=#dagger-oh-my>#</a></h1><p>N26 has a long history with Dagger. We have been using it for years, we developed our customizations and libraries on top of it, and many of our architectural decisions were made relying on Dagger features.</p><p>Dagger is excellent but comes with a price when used with Kotlin. The more we grew, the more we were charged. Stub generation issues, slow build time, increasing boilerplate to wire <code>@dagger.Component</code>, new joiners avoided touching the graphs due to complexity&mldr;</p><p>Looking for solutions, we found <a href=https://dagger.dev/hilt/>Hilt by Google</a>. We enjoyed many of the ideas they proposed as the <a href=https://dagger.dev/hilt/monolithic.html>Monolithic Component</a> and the <a href=https://dagger.dev/hilt/testing.html>testing philosophy</a>. But the trade-off was not that good for us: a migration would be painful and would take months to years, to not say we did not appreciate the byte code manipulation and the extra KAPT processor.</p><p>Simultaneously, another solution appeared, which solved some of the same problems differently: <a href=https://github.com/square/anvil>Anvil</a>.</p><blockquote><p>Anvil is a Kotlin compiler plugin to make dependency injection with Dagger easier by automatically merging Dagger modules and component interfaces.</p></blockquote><h1 id=sharpening-your-blade>Sharpening your blade<a hidden class=anchor aria-hidden=true href=#sharpening-your-blade>#</a></h1><p>To get an idea of how Anvil would affect us, we started with a set of experiments. The first one would be to wire a few modules while keeping backward compatibility without impacting any feature developer. In a matter of hours, we managed to conclude it. In a week, we had many modules using Anvil. We did not identify any expressive build time impact.</p><p>We were happy with the result. We decided to be more ambitious: we selected our code base&rsquo;s prominent monolith module to fully migrated to Anvil, and afterward, we broke this monolith apart into small libraries. It took us a few months to complete the goal, but we succeeded and did not identify any expressive build time impact, again.</p><p>To be sure we were on the right path, we mapped the relationship of a few of our most complex modules before and after adopting Anvil. For a matter of company&rsquo;s privacy, all text is blurred, but you can still see the positive impact by noting the arrows:</p><p><img loading=lazy src=/images/2021/02/05/before-and-after.png alt="Before and After"></p><p>Finally, we decided to go full Anvil: we turned on <a href=https://github.com/square/anvil#dagger-factory-generation>Anvil&rsquo;s Dagger Factory generation</a> in all modules that we could (20+ at the time). We identified build times improvements of ~50% for individual modules build times, ~10% for Sample Apps, and because Anvil does not rely on KAPT, we never saw any KAPT issue again on those modules.</p><p><img loading=lazy src=/images/2021/02/05/benchmark.png alt=Benchmark></p><p>Many improvements, but we believed we could take it further: let&rsquo;s take the good things from Hilt and bring it to Anvil.</p><h1 id=hilt-to-anvil>Hilt to Anvil<a hidden class=anchor aria-hidden=true href=#hilt-to-anvil>#</a></h1><p>We decided to adopt what we like from Hilt while using Anvil.</p><p>The first point was to provide a single monolith component, and for that, we started to merge the components and use Anvil&rsquo;s <code>@ContributesTo</code> to binding the modules instead. It took quite some time, it was challenging but it worked well.</p><p>The second one was to support some Jetpack Libraries. We started with <code>FragmentFactory</code> to leverage the constructor injector as much as possible. We created a <code>@FragmentKey</code> and used Dagger&rsquo;s multi-binding to wire everything. Here is how the code might look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@ContributesBinding</span>(Singleton<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>, FragmentFactory<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultibindingFragmentFactory</span> <span style=color:#a6e22e>@Inject</span> <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> map: Map&lt;Class&lt;<span style=color:#66d9ef>out</span> Fragment&gt;, <span style=color:#a6e22e>@JvmSuppressWildcards</span> Provider&lt;Fragment&gt;&gt;
</span></span><span style=display:flex><span>) : FragmentFactory() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>instantiate</span>(classLoader: ClassLoader, className: String): Fragment {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> fragmentClass = loadFragmentClass(classLoader, className)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> map[fragmentClass]<span style=color:#f92672>?.</span><span style=color:#66d9ef>get</span>() <span style=color:#f92672>?:</span> <span style=color:#66d9ef>super</span>.instantiate(classLoader, className)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(
</span></span><span style=display:flex><span>    AnnotationTarget.CLASS,
</span></span><span style=display:flex><span>    AnnotationTarget.FUNCTION
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Retention</span>(value = AnnotationRetention.RUNTIME)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@MapKey</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>annotation</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FragmentKey</span>(<span style=color:#66d9ef>val</span> value: KClass&lt;<span style=color:#66d9ef>out</span> Fragment&gt;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Activity</span> : AppCompatActivity() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> component: MainComponent
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>() = TODO(<span style=color:#e6db74>&#34;Retrieve your Monolith Component&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style=display:flex><span>        supportFragmentManager.fragmentFactory = component.getFragmentFactory()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.onCreate(savedInstanceState)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now to wire your <code>Fragment</code>, you can simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@ContributesMultibinding</span>(Singleton<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@FragmentKey</span>(HomeFragment<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeFragment</span> <span style=color:#a6e22e>@Inject</span> <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Dependencies goes here. :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>) : Fragment()
</span></span></code></pre></div><p>For more details around Fragments, check the <a href=https://developer.android.com/guide/fragments>official guide</a>.</p><p>Having a Monolith Component and relying on Fragment&rsquo;s constructor injector means we can invoke any fragment from any place of our application, and things &ldquo;will work&rdquo;. Scoping becomes intuitive for those classes. If you inject an object in the <code>Fragment</code> is a fragment scope, if you inject into the <code>ViewModel</code> is a view model scope. We also offer a <code>SessionScope</code> and <code>Singleton</code> scope.</p><p>For <code>ViewModels</code> a simple <code>Provider&lt;ViewModel></code> or <code>AssistedInject</code>, if you need an instance of <code>SavedStateHandle</code>, will do the trick.</p><p>And finally, testing: Anvil offers a <a href=https://github.com/square/anvil#exclusions>replace module feature</a> that is handful to provide new dependencies during tests. For that, we create helper modules called <code>testing</code> and we provide fake dependencies of those replacing the production modules. Developers that include the <code>testing</code> in their test classpath can automatically interact with our testing utilities (or create their own, if required). To be completely honest here, it is more of an ongoing process.</p><p><img loading=lazy src=/images/2021/02/05/module-structure.png alt="Module Structure"></p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Anvil is a robust and straightforward solution. It does what it suppose to do and does it well. It benefits from a seamless synergy with Dagger, while not being opinionated and letting you decide how you integrate with other libraries (or not integrating it at all).</p><p>Also, the fact it does not rely on KAPT is a <strong>tremendous advantage</strong> for large projects and should be kept in mind while deciding between Anvil or Hilt. I&rsquo;m delighted with the overall experience, and I enjoy seeing how many feature developers started to migrate away from KAPT to Anvil proactively:</p><p><img loading=lazy src=/images/2021/02/05/no-more-kapt.png alt="Kill KAPT"></p><p>Finally, as you can see above, many of the Hilt&rsquo;s features can be implemented in Anvil. However, it is vital to keep in mind Anvil is not a silver bullet. It is essential to have people in your team that understand Dagger and Dependency Injection to build the integrations you might need.</p><h1 id=update-20210225>Update 2021.02.25<a hidden class=anchor aria-hidden=true href=#update-20210225>#</a></h1><p>As many people reached out asking advice on how to implement some Hilt features (e.g., ViewModelScope, SavedStateHandle, and others), I created a <a href=https://github.com/marcellogalhardo/hilt-to-anvil>small showcase project</a>.</p><h1 id=update-20210319>Update 2021.03.19<a hidden class=anchor aria-hidden=true href=#update-20210319>#</a></h1><p>Updated <code>MultibindingFragmentFactory</code> example and <a href=https://github.com/marcellogalhardo/hilt-to-anvil>showcase project</a> to use new <code>@ContributesMultibinding</code> from <a href=https://github.com/square/anvil/releases/tag/v2.2.0>Anvil 2.2.0</a>.</p><h1 id=credits>Credits<a hidden class=anchor aria-hidden=true href=#credits>#</a></h1><p>Thanks to <a href=https://twitter.com/mchietera>Maria Chietera</a>, <a href=https://twitter.com/orafaaraujo>Rafael Araujo</a>, <a href=https://twitter.com/laggedHero>Tiago Cunha</a>, <a href=https://twitter.com/fabiocarballo>Fabio Carballo</a>, and <a href=https://twitter.com/s_anastasov>Stojan Anastasov</a> proofread review! 🔍</p><p>And a special thank you to <a href=https://twitter.com/vRallev>Ralf Wondratschek</a> for early feedback and creating Anvil! :knife:</p><hr><blockquote><p>ℹ️ To stay up to date with my writing, follow me on <a href=https://twitter.com/marcellogalhard>Twitter</a> or <a href=http://androiddev.social/@mg>Mastodon</a>. If you have any questions or I missed something, feel free to reach out to me! ℹ️</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/android/>android</a></li><li><a href=https://marcellogalhardo.dev/tags/dagger/>dagger</a></li><li><a href=https://marcellogalhardo.dev/tags/anvil/>anvil</a></li></ul></footer></article></main><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://marcellogalhardo.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></body></html>