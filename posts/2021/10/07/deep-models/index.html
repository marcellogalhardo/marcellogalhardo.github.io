<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deep Models | Marcello Galhardo</title><meta name=keywords content="kotlin"><meta name=description content="Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on &ldquo;How can I code this?&rdquo;, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.
To better explain, let&rsquo;s consider the hypothetical requirements:"><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/2021/10/07/deep-models/><link href=https://androiddev.social/@mg rel=me><link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.107.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Deep Models"><meta property="og:description" content="Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on &ldquo;How can I code this?&rdquo;, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.
To better explain, let&rsquo;s consider the hypothetical requirements:"><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/2021/10/07/deep-models/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-07T09:02:50+01:00"><meta property="article:modified_time" content="2021-10-07T09:02:50+01:00"><meta property="og:site_name" content="Marcello Galhardo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deep Models"><meta name=twitter:description content="Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on &ldquo;How can I code this?&rdquo;, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.
To better explain, let&rsquo;s consider the hypothetical requirements:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Deep Models","item":"https://marcellogalhardo.dev/posts/2021/10/07/deep-models/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deep Models","name":"Deep Models","description":"Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on \u0026ldquo;How can I code this?\u0026rdquo;, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.\nTo better explain, let\u0026rsquo;s consider the hypothetical requirements:","keywords":["kotlin"],"articleBody":"Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on “How can I code this?”, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.\nTo better explain, let’s consider the hypothetical requirements:\nYour team is developing a feature to order items in e-commerce. Your job is to design the models of this feature. The simplest way to do that might look like the code below.\nfun findOrderById(id: String): Order data class Order( val id: String, val accountId: String, val items: List, // ...billing address, shipping address, status, and other properties. ) data class OrderItem( val id: String, val name: String, val quantity: Int, val price: BigDecimal, ) At first glance, these models will look good, but let’s have a closer look.\nPrimitive Obsession: almost all types are String, and the compiler is incapable of verifying their integrity. Absence of Invariants: it is unrealistic to define a quantity as a number between -2147483648 and 2147483647. What is a quantity -1? Error Prone: what happens if you create an Order with an empty accountId? What will happen if you call findOrderById with an OrderItem.id by mistake? Good models get out of developers’ way by making invalid state impossible. More than that, it leverages the compiler to not allow human’s mistake (e.g., an OrderItemId should not be used as an OrderId).\nLet’s redesign the previous model.\nfun findOrderById(id: OrderId): Order data class Order( val id: OrderId, val accountId: OrderAccountId, val items: List, ) @JvmInline value class OrderId(val value: String) { init { runCatching { UUID.fromString(value) } .onFailure { e -\u003e error(\"OrderId should be a valid UUID but found: $value.\") } } } @JvmInline value class OrderAccountId(val value: String) { init { runCatching { UUID.fromString(value) } .onFailure { e -\u003e error(\"AccountId should be a valid UUID but found: $value.\") } } } data class OrderItem( val id: OrderItemId, val name: OrderItemName, val quantity: OrderItemQuantity, val price: OrderItemPrice, ) @JvmInline value class OrderItemId(val value: String) { init { runCatching { UUID.fromString(value) } .onFailure { e -\u003e error(\"OrderItemId should be a valid UUID but found: $value.\") } } } @JvmInline value class OrderItemName(val value: String) { init { require(value.isNotBlank()) { \"OrderItemName should not be blank.\" } require(value.length \u003c 200) { \"OrderItemName length should be smaller than 200 but found: ${value.length} with content: $value.\"} } } @JvmInline value class OrderItemQuantity(val value: Int) { init { require(value \u003e= 0) { \"OrderItemQuantity should not be negative but found: $value.\" } require(value \u003c 99) { \"OrderItemQuantity should not be higher than 99 but found: $value.\" } } } @JvmInline value class OrderItemPrice(val value: BigDecimal) { init { require(value \u003e BigDecimal.ZERO) { \"OrderItemPrice should not be negative but found: $value.\" } } } The new API makes it impossible to create an invalid instance of an Order. It ensures all invariants of an Order are respected during the application’s lifetime and reduces corner cases by providing a type-safe API: the function findOrderById knows that you are calling it with an OrderId, it will be a valid UUID.\nF.A.Q. What about the number of classes? Good models often will involve more classes and specific validations - but keep in mind those are already in our code. Remember all those checks to verify if the parameter of findOrderById is valid? Or that IllegalArgumentException when you expected a quantity but received a negative number? Now they are explicitly defined in our domain and can be easily found.\nWhat about the number of lines of code? It is true that now you need to cover more ground, but it is also true that you reduced the number of corner cases. Before, your tests had to cover if the findOrderById parameter is valid. Now, the compiler will ensure the parameter is always correct - if the code compiles, you know you are receiving a correct UUID. In the end, you are making safer code and reducing the number of tests you will need.\nShould I have a class for each property? Probably not. Modeling requires a lot of analysis. You must identify the essential concepts of your domain that must be assertive and ensure those are deep. For that, Domain-Driven Design might help you.\nCredits Special credits for Secure By Design (Chapter 2: Shallow Modeling) and A Philosophy of Software Design (Chapter 4: Modules should be deep) where I learnt about Deep and Shallow modeling, both exceptional books.\nIf you like my posts, follow me on Twitter: @marcellogalhard\n","wordCount":"776","inLanguage":"en","datePublished":"2021-10-07T09:02:50+01:00","dateModified":"2021-10-07T09:02:50+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/2021/10/07/deep-models/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Deep Models</h1><div class=post-meta>October 7, 2021</div></header><div class=post-content><p>Modeling is a critical task in Software Development: good models reduce the risk of bugs, increase readability and improve maintainability. However, we can often see developers focusing on <em>&ldquo;How can I code this?&rdquo;</em>, and they are done with their task when they find a way to code it. This inherently reduces the domain modeling to the abuse of primitives and shallow design where any inconsistent state is allowed.</p><p>To better explain, let&rsquo;s consider the hypothetical requirements:</p><ul><li>Your team is developing a feature to order items in e-commerce.</li><li>Your job is to design the models of this feature.</li></ul><p>The simplest way to do that might look like the code below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>findOrderById</span>(id: String): Order
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Order</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> id: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> accountId: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> items: List&lt;OrderItem&gt;,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...billing address, shipping address, status, and other properties.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderItem</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> id: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> quantity: Int,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> price: BigDecimal,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>At first glance, these models will look good, but let&rsquo;s have a closer look.</p><ol><li><a href=https://refactoring.guru/smells/primitive-obsession>Primitive Obsession</a>: almost all types are String, and the compiler is incapable of verifying their integrity.</li><li><a href=https://medium.com/code-design/invariants-in-code-design-557c7864a047>Absence of Invariants</a>: it is unrealistic to define a quantity as a number between <code>-2147483648</code> and <code>2147483647</code>. What is a quantity <code>-1</code>?</li><li><a href="https://www.youtube.com/watch?v=t3DBzaeid74">Error Prone</a>: what happens if you create an <code>Order</code> with an empty <code>accountId</code>? What will happen if you call <code>findOrderById</code> with an <code>OrderItem.id</code> by mistake?</li></ol><p>Good models get out of developers&rsquo; way by making invalid state impossible. More than that, it leverages the compiler to not allow human&rsquo;s mistake (e.g., an <code>OrderItemId</code> should not be used as an <code>OrderId</code>).</p><p>Let&rsquo;s redesign the previous model.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>findOrderById</span>(id: OrderId): Order
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Order</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> id: OrderId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> accountId: OrderAccountId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> items: List&lt;OrderItem&gt;,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@JvmInline</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderId</span>(<span style=color:#66d9ef>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        runCatching { <span style=color:#a6e22e>UUID</span>.fromString(<span style=color:#66d9ef>value</span>) }
</span></span><span style=display:flex><span>            .onFailure { e <span style=color:#f92672>-&gt;</span> error(<span style=color:#e6db74>&#34;OrderId should be a valid UUID but found: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span>) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@JvmInline</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderAccountId</span>(<span style=color:#66d9ef>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        runCatching { <span style=color:#a6e22e>UUID</span>.fromString(<span style=color:#66d9ef>value</span>) }
</span></span><span style=display:flex><span>            .onFailure { e <span style=color:#f92672>-&gt;</span> error(<span style=color:#e6db74>&#34;AccountId should be a valid UUID but found: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span>) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderItem</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> id: OrderItemId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> name: OrderItemName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> quantity: OrderItemQuantity,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> price: OrderItemPrice,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@JvmInline</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderItemId</span>(<span style=color:#66d9ef>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        runCatching { <span style=color:#a6e22e>UUID</span>.fromString(<span style=color:#66d9ef>value</span>) }
</span></span><span style=display:flex><span>            .onFailure { e <span style=color:#f92672>-&gt;</span> error(<span style=color:#e6db74>&#34;OrderItemId should be a valid UUID but found: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span>) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@JvmInline</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderItemName</span>(<span style=color:#66d9ef>val</span> value: String) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#66d9ef>value</span>.isNotBlank()) { <span style=color:#e6db74>&#34;OrderItemName should not be blank.&#34;</span> }
</span></span><span style=display:flex><span>        require(<span style=color:#66d9ef>value</span>.length &lt; <span style=color:#ae81ff>200</span>) { <span style=color:#e6db74>&#34;OrderItemName length should be smaller than 200 but found: </span><span style=color:#e6db74>${value.length}</span><span style=color:#e6db74> with content: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@JvmInline</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderItemQuantity</span>(<span style=color:#66d9ef>val</span> value: Int) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#66d9ef>value</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) { <span style=color:#e6db74>&#34;OrderItemQuantity should not be negative but found: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span> }
</span></span><span style=display:flex><span>        require(<span style=color:#66d9ef>value</span> &lt; <span style=color:#ae81ff>99</span>) { <span style=color:#e6db74>&#34;OrderItemQuantity should not be higher than 99 but found: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@JvmInline</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderItemPrice</span>(<span style=color:#66d9ef>val</span> value: BigDecimal) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        require(<span style=color:#66d9ef>value</span> &gt; <span style=color:#a6e22e>BigDecimal</span>.ZERO) { <span style=color:#e6db74>&#34;OrderItemPrice should not be negative but found: </span><span style=color:#e6db74>$value</span><span style=color:#e6db74>.&#34;</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The new API makes it impossible to create an invalid instance of an <code>Order</code>. It ensures all invariants of an <code>Order</code> are respected during the application&rsquo;s lifetime and reduces corner cases by providing a type-safe API: the function <code>findOrderById</code> knows that you are calling it with an <code>OrderId</code>, it will be a valid <code>UUID</code>.</p><h2 id=faq>F.A.Q.<a hidden class=anchor aria-hidden=true href=#faq>#</a></h2><ol><li>What about the number of classes?</li></ol><p>Good models often will involve more classes and specific validations - but keep in mind those are already in our code. Remember all those checks to verify if the parameter of <code>findOrderById</code> is valid? Or that <code>IllegalArgumentException</code> when you expected a quantity but received a negative number? Now they are explicitly defined in our domain and can be easily found.</p><ol start=2><li>What about the number of lines of code?</li></ol><p>It is true that now you need to cover more ground, but it is also true that you reduced the number of corner cases. Before, your tests had to cover if the <code>findOrderById</code> parameter is valid. Now, the compiler will ensure the parameter is always correct - if the code compiles, you know you are receiving a correct <code>UUID</code>. In the end, you are making safer code and reducing the number of tests you will need.</p><ol start=3><li>Should I have a class for each property?</li></ol><p>Probably not. Modeling requires a lot of analysis. You must identify the essential concepts of your domain that must be assertive and ensure those are deep. For that, <a href=https://martinfowler.com/bliki/DomainDrivenDesign.html>Domain-Driven Design</a> might help you.</p><h1 id=credits>Credits<a hidden class=anchor aria-hidden=true href=#credits>#</a></h1><p>Special credits for <a href=https://www.manning.com/books/secure-by-design>Secure By Design</a> (Chapter 2: Shallow Modeling) and <a href=https://www.amazon.de/-/en/John-Ousterhout/dp/1732102201>A Philosophy of Software Design</a> (Chapter 4: Modules should be deep) where I learnt about Deep and Shallow modeling, both exceptional books.</p><p>If you like my posts, follow me on Twitter: <a href=https://twitter.com/marcellogalhard>@marcellogalhard</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/kotlin/>kotlin</a></li></ul></footer></article></main><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2022</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://marcellogalhardo.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></body></html>