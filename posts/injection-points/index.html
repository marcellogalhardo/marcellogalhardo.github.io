<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Injection Points | Marcello Galhardo</title><meta name=keywords content="android,kotlin"><meta name=description content="Injection Points Android has made significant progress in becoming a DI-Friendly Framework. Throughout the years, new APIs like AppComponentFactory and FragmentFactory have been introduced, allowing apps to incorporate their own custom constructors and facilitating the development of testable code.
Please keep in mind that I will not delve into the concept of DI, SL, specific libraries or its significance. Instead, the focus will be solely on the Android APIs that enable constructor injection."><meta name=author content><link rel=canonical href=https://marcellogalhardo.dev/posts/injection-points/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://marcellogalhardo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marcellogalhardo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marcellogalhardo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://marcellogalhardo.dev/apple-touch-icon.png><link rel=mask-icon href=https://marcellogalhardo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7LK7ENB813"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7LK7ENB813",{anonymize_ip:!1})}</script><meta property="og:title" content="Injection Points"><meta property="og:description" content="Injection Points Android has made significant progress in becoming a DI-Friendly Framework. Throughout the years, new APIs like AppComponentFactory and FragmentFactory have been introduced, allowing apps to incorporate their own custom constructors and facilitating the development of testable code.
Please keep in mind that I will not delve into the concept of DI, SL, specific libraries or its significance. Instead, the focus will be solely on the Android APIs that enable constructor injection."><meta property="og:type" content="article"><meta property="og:url" content="https://marcellogalhardo.dev/posts/injection-points/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-02T09:12:00+01:00"><meta property="article:modified_time" content="2023-06-02T09:12:00+01:00"><meta property="og:site_name" content="Marcello Galhardo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Injection Points"><meta name=twitter:description content="Injection Points Android has made significant progress in becoming a DI-Friendly Framework. Throughout the years, new APIs like AppComponentFactory and FragmentFactory have been introduced, allowing apps to incorporate their own custom constructors and facilitating the development of testable code.
Please keep in mind that I will not delve into the concept of DI, SL, specific libraries or its significance. Instead, the focus will be solely on the Android APIs that enable constructor injection."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marcellogalhardo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Injection Points","item":"https://marcellogalhardo.dev/posts/injection-points/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Injection Points","name":"Injection Points","description":"Injection Points Android has made significant progress in becoming a DI-Friendly Framework. Throughout the years, new APIs like AppComponentFactory and FragmentFactory have been introduced, allowing apps to incorporate their own custom constructors and facilitating the development of testable code.\nPlease keep in mind that I will not delve into the concept of DI, SL, specific libraries or its significance. Instead, the focus will be solely on the Android APIs that enable constructor injection.","keywords":["android","kotlin"],"articleBody":"Injection Points Android has made significant progress in becoming a DI-Friendly Framework. Throughout the years, new APIs like AppComponentFactory and FragmentFactory have been introduced, allowing apps to incorporate their own custom constructors and facilitating the development of testable code.\nPlease keep in mind that I will not delve into the concept of DI, SL, specific libraries or its significance. Instead, the focus will be solely on the Android APIs that enable constructor injection. If you are interested in learning more about the concepts of DI, I recommend exploring resources on Dependency Injection in Android.\nAdditionally, it is important to note that Dagger Hilt and Koin Android simplifies the dependency wiring process by handling almost it all for you.\nThe purpose of this article is to highlight some of the Android APIs that are utilised behind the scenes. By exploring these APIs, developers can gain a better understanding of the underlying mechanisms employed such libraries.\nAppComponentFactory Starting from API Level 28, you can use the AppComponentFactory abstract class to customise the instantiation of application component objects declared in your manifest, such as Application, Activity, Service, and ContentProvider.\nHere’s how you can use it.\n Create a new class that extends AppComponentFactory, and override the appropriate methods.  class MyAppComponentFactory : AppComponentFactory() {   // Customize the instantiation of Application class here  override fun instantiateApplication(  classLoader: ClassLoader,  className: String,  ): Application = when (className) {  MyApplication::class.java.name - MyApplication()   // Fallback to Android's default implementation.  else - super.instantiateApplication(cl, className)  }   // Customize the instantiation of Activity class here  override fun instantiateActivity(  classLoader: ClassLoader,  className: String,  intent: Intent,  ): Activity = when (className) {  MyActivity::class.java.name - MyActivity()   // Fallback to Android's default implementation.  else - super.instantiateActivity(cl, className, intent)  }   // Override other `instantiate*` methods here } Declare your custom AppComponentFactory in the AndroidManifest.xml file by adding the android:appComponentFactory attribute to the  tag.   android:appComponentFactory=\".MyAppComponentFactory\" / Disclaimer: contrary to the belief of many, the latest Android API Version Distribution, last updated on January 6th, 2023, reveals that API 28 and above comprise a significant majority of the Android market, accounting for approximately 81%.\nLayoutInflater.Factory and View Starting from API Level 11, you can use the LayoutInflater.Factory2 interface to customise the inflation of a View instance.\nHere’s how you can use it.\n Create a new class that implements LayoutInflater.Factory2, and override the appropriate methods.  class MyLayoutInflaterFactory : LayoutInflater.Factory2 {   // Create and return a custom View based on the parent, name, context, and attributes  override fun onCreateView(  parent: View?,  name: String,  context: Context,  attrs: AttributeSet,  ): View? = when (name) {  MyCustomView::class.java.name - MyCustomView(context, attrs, /* defStyleAttr = */ null)   // Return null to fallback to Android's default implementation.  else - null  }   override fun onCreateView(name: String, context: Context, attrs: AttributeSet): View? =  onCreateView(null, name, context, attrs) } Set your custom LayoutInflater.Factory2 on your Activity .  class MainActivity : Activity() {   override fun onCreate(savedInstanceState: Bundle?) {  layoutInflater.factory2 = MyLayoutInflaterFactory()  super.onCreate(savedInstanceState)   // Your activity initialization and logic here  }   // Other overridden methods and custom methods here } AppCompat Exception Setting a custom LayoutInflater.Factory2 will crash if you use AppCompat (for example, AppCompatActivity).\n java.lang.IllegalStateException: A factory has already been set on this LayoutInflater.\n That is by design. AppCompat relies on a custom LayoutInflater.Factory2 that must be set to work as expected.\nHere’s a workaround.\n Remove the previous code from from your Activity’s onCreate. Create a new class that implements LayoutInflater.Factory2, and receives 2 LayoutInflater.Factor2 as parameters:  base to handle your custom views with constructor injector. fallback which will be used to handle all other views.    class LayoutInflaterFactory2Wrapper(  val base: LayoutInflater.Factory2?,  val fallback: LayoutInflater.Factory2?, ) : LayoutInflater.Factory2 {   override fun onCreateView(  parent: View?,  name: String?,  context: Context?,  attrs: AttributeSet?,  ): View? = base?.onCreateView(parent, name, context, attrs)  ?: fallback?.onCreateView(parent, name, context, attrs)   override fun onCreateView(  name: String,  context: Context,  attrs: AttributeSet?,  ): View? = onCreateView(/* parent = */ null, name, context, attrs) } Create a new class that extends ContextWrapper, and override the getSystemService method.  class MyContextWrapper(  base: Context,  private val baseFactory: LayoutInflater.Factory2, ) : ContextWrapper(base) {   private val inflater: LayoutInflater by lazy {  LayoutInflater  .from(baseContext)  .cloneInContext(/* newContext = */ this)  .apply { factory = LayoutInflaterFactory2Wrapper(baseFactory, factory2) }  }   override fun getSystemService(name: String): Any? =  if (LAYOUT_INFLATER_SERVICE != name) {  super.getSystemService(name)  } else {  inflater  } } Set your custom ContextWrapper on your Activity .  class MainActivity : AppCompatActivity() {   override fun attachBaseContext(newBase: Context) {  val factory = MyLayoutInflaterFactory()  val wrapper = MyContextWrapper(newBase, factory)  super.attachBaseContext(wrapper);  } } FragmentFactory Starting from androidx.fragment version 1.1.0-alpha01, you can use the FragmentFactory abstract class to customise the creation of a Fragment instance.\nHere’s how you can use it.\n Create a new class that extends FragmentFactory, and override the appropriate methods.  class MyFragmentFactory : FragmentFactory() {   override fun instantiate(  classLoader: ClassLoader,  className: String,  ): Fragment = when (className) {  MyFragment::class.java.name - MyFragment()   // Fallback to Android's default implementation.  else - super.instantiate(classLoader, className)  } } Set your custom FragmentFactory instance on your FragmentActivity (or Fragment) before any fragment operations are performed.  class MyActivity : FragmentActivity() {   override fun onCreate(savedInstanceState: Bundle?) {  supportFragmentManager.fragmentFactory = MyFragmentFactory()  super.onCreate(savedInstanceState)   // Your activity initialization and logic here  }   // Other overridden methods and custom methods here } ViewModel Starting from androidx.lifecycle version 2.5.0-alpha01, you can use the ViewModelProvider.Factory with the CreationExtras to simplify the ViewModel creation (for example, SavedStateHandle).\nHere’s how you can use it.\n Create a new class that implements ViewModelProvider.Factory, and override the appropriate methods.  class MyViewModelFactory : ViewModelProvider.Factory {   @Suppress(\"UNCHECKED_CAST\")  override fun T : ViewModel create(  modelClass: Class,  extras: CreationExtras,  ): T = when (modelClass) {  MyViewModel::class.java - MyViewModel(extras.createSavedStateHandle())  else - error(\"Unknown ViewModel class: $modelClass\")  } as T } When you need to create an instance of MyViewModel, use the MyViewModelFactory.  val viewModel by viewModels { MyViewModelFactory() } WorkManager and WorkerFactory Starting from androidx.work version 1.0.0-alpha09, you can use the WorkerFactory interface to customise the creation of an Worker instance.\nHere’s how you can use it.\n Remove the default initialiser. Create a custom WorkerFactory implementation.  class MyWorkerFactory : WorkerFactory() {   // Customize the creation of your worker based on the workerClassName and workerParameters  override fun createWorker(  appContext: Context,  workerClassName: String,  workerParameters: WorkerParameters,  ): ListenableWorker? = when (workerClassName) {  MyWorker::class.java.name - MyWorker(appContext, workerParameters),   // Return null to fallback to Android's default implementation.  else - null,  } } In the createWorker method, you can inspect the workerClassName and workerParameters to determine the appropriate worker instance to create. Return null if you don’t want to handle the given workerClassName and let the default factory handle it.\nSet the custom WorkerFactory to WorkManager: In your application’s initialisation code, before using WorkManager, set your custom WorkerFactory using Configuration:  val configuration = Configuration.Builder()  .setWorkerFactory(MyWorkerFactory())  .build()  WorkManager.initialize(context, configuration) Wrapping Up In conclusion, Android has made notable strides in becoming a DI-friendly framework by introducing various APIs that enable dependency injection.\nThe article covered several key APIs used by the two most popular DI frameworks for Android.\n AppComponentFactory for customising the instantiation of application components. LayoutInflater.Factory2 and View for customising view inflation. FragmentFactory for customising fragment creation. ViewModelProvider.Factory with CreationExtras for simplifying ViewModel creation. WorkerFactory for customising Worker creation in WorkManager.  Credits Special thanks to Maria Chietera, and Fred Porciúncula proofread review! 🔍\n  ℹ️ To stay up to date with my writing, follow me on Twitter or Mastodon. If you have any questions or I missed something, feel free to reach out to me! ℹ️\n ","wordCount":"1218","inLanguage":"en","datePublished":"2023-06-02T09:12:00+01:00","dateModified":"2023-06-02T09:12:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://marcellogalhardo.dev/posts/injection-points/"},"publisher":{"@type":"Organization","name":"Marcello Galhardo","logo":{"@type":"ImageObject","url":"https://marcellogalhardo.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://marcellogalhardo.dev/ accesskey=h title="Marcello Galhardo (Alt + H)">Marcello Galhardo</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://marcellogalhardo.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://marcellogalhardo.dev/talks title=Talks><span>Talks</span></a></li><li><a href=https://marcellogalhardo.dev/about title=About><span>About</span></a></li><li><a href=https://marcellogalhardo.dev/uses title=Uses><span>Uses</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Injection Points</h1><div class=post-meta><span title="2023-06-02 09:12:00 +0100 +0100">June 2, 2023</span></div></header><div class=post-content><h1 id=injection-points>Injection Points<a hidden class=anchor aria-hidden=true href=#injection-points>#</a></h1><p>Android has made significant progress in becoming a <a href=https://blog.ploeh.dk/2014/05/19/di-friendly-framework/>DI-Friendly Framework</a>. Throughout the years, new APIs like <code>AppComponentFactory</code> and <code>FragmentFactory</code> have been introduced, allowing apps to incorporate their own custom constructors and facilitating the development of testable code.</p><p>Please keep in mind that I will not delve into the concept of DI, SL, specific libraries or its significance. Instead, the focus will be solely on the Android APIs that enable constructor injection. If you are interested in learning more about the concepts of DI, I recommend exploring resources on <a href=https://developer.android.com/training/dependency-injection>Dependency Injection in Android</a>.</p><p>Additionally, it is important to note that <a href=https://developer.android.com/training/dependency-injection/hilt-android>Dagger Hilt</a> and <a href=https://insert-koin.io/docs/quickstart/android/>Koin Android</a> simplifies the dependency wiring process by handling almost it all for you.</p><p>The purpose of this article is to highlight some of the Android APIs that are utilised behind the scenes. By exploring these APIs, developers can gain a better understanding of the underlying mechanisms employed such libraries.</p><h2 id=appcomponentfactory>AppComponentFactory<a hidden class=anchor aria-hidden=true href=#appcomponentfactory>#</a></h2><p>Starting from <a href=https://developer.android.com/reference/android/app/AppComponentFactory>API Level 28</a>, you can use the <code>AppComponentFactory</code> abstract class to customise the instantiation of application component objects declared in your manifest, such as <code>Application</code>, <code>Activity</code>, <code>Service</code>, and <code>ContentProvider</code>.</p><p>Here&rsquo;s how you can use it.</p><ol><li>Create a new class that extends <code>AppComponentFactory</code>, and override the appropriate methods.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyAppComponentFactory</span> : AppComponentFactory() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Customize the instantiation of Application class here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>instantiateApplication</span>(
</span></span><span style=display:flex><span>        classLoader: ClassLoader,
</span></span><span style=display:flex><span>        className: String,
</span></span><span style=display:flex><span>    ): Application = <span style=color:#66d9ef>when</span> (className) {
</span></span><span style=display:flex><span>        MyApplication<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java.name <span style=color:#f92672>-&gt;</span> MyApplication()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fallback to Android&#39;s default implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>super</span>.instantiateApplication(cl, className)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Customize the instantiation of Activity class here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>instantiateActivity</span>(
</span></span><span style=display:flex><span>        classLoader: ClassLoader,
</span></span><span style=display:flex><span>        className: String,
</span></span><span style=display:flex><span>        intent: Intent,
</span></span><span style=display:flex><span>    ): Activity = <span style=color:#66d9ef>when</span> (className) {
</span></span><span style=display:flex><span>        MyActivity<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java.name <span style=color:#f92672>-&gt;</span> MyActivity()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fallback to Android&#39;s default implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>super</span>.instantiateActivity(cl, className, intent)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Override other `instantiate*` methods here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ol start=2><li>Declare your custom <code>AppComponentFactory</code> in the <code>AndroidManifest.xml</code> file by adding the <code>android:appComponentFactory</code> attribute to the <code>&lt;application></code> tag.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;application</span> <span style=color:#a6e22e>android:appComponentFactory=</span><span style=color:#e6db74>&#34;.MyAppComponentFactory&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p><strong>Disclaimer:</strong> contrary to the belief of many, the latest Android API Version Distribution, last updated on January 6th, 2023, reveals that API 28 and above comprise a significant majority of the Android market, accounting for approximately 81%.</p><h2 id=layoutinflaterfactory-and-view>LayoutInflater.Factory and View<a hidden class=anchor aria-hidden=true href=#layoutinflaterfactory-and-view>#</a></h2><p>Starting from <a href=https://developer.android.com/reference/android/view/LayoutInflater.Factory2>API Level 11</a>, you can use the <code>LayoutInflater.Factory2</code> interface to customise the inflation of a <code>View</code> instance.</p><p>Here&rsquo;s how you can use it.</p><ol><li>Create a new class that implements <code>LayoutInflater.Factory2</code>, and override the appropriate methods.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyLayoutInflaterFactory</span> : LayoutInflater.Factory2 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create and return a custom View based on the parent, name, context, and attributes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreateView</span>(
</span></span><span style=display:flex><span>        parent: View?,
</span></span><span style=display:flex><span>        name: String,
</span></span><span style=display:flex><span>        context: Context,
</span></span><span style=display:flex><span>        attrs: AttributeSet,
</span></span><span style=display:flex><span>    ): View? = <span style=color:#66d9ef>when</span> (name) {
</span></span><span style=display:flex><span>        MyCustomView<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java.name <span style=color:#f92672>-&gt;</span> MyCustomView(context, attrs, <span style=color:#75715e>/* defStyleAttr = */</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Return null to fallback to Android&#39;s default implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreateView</span>(name: String, context: Context, attrs: AttributeSet): View? =
</span></span><span style=display:flex><span>        onCreateView(<span style=color:#66d9ef>null</span>, name, context, attrs)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>Set your custom <code>LayoutInflater.Factory2</code> on your <code>Activity</code> .</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivity</span> : Activity() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style=display:flex><span>        layoutInflater.factory2 = MyLayoutInflaterFactory()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.onCreate(savedInstanceState)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Your activity initialization and logic here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Other overridden methods and custom methods here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=appcompat-exception>AppCompat Exception<a hidden class=anchor aria-hidden=true href=#appcompat-exception>#</a></h3><p>Setting a custom <code>LayoutInflater.Factory2</code> will crash if you use <code>AppCompat</code> (for example, <code>AppCompatActivity</code>).</p><blockquote><p>java.lang.IllegalStateException: A factory has already been set on this LayoutInflater.</p></blockquote><p>That is by design. <code>AppCompat</code> relies on a custom <code>LayoutInflater.Factory2</code> that must be set to work as expected.</p><p>Here&rsquo;s a workaround.</p><ol><li>Remove the previous code from from your Activity&rsquo;s <code>onCreate</code>.</li><li>Create a new class that implements <code>LayoutInflater.Factory2</code>, and receives 2 <code>LayoutInflater.Factor2</code> as parameters:<ul><li><code>base</code> to handle your custom views with constructor injector.</li><li><code>fallback</code> which will be used to handle all other views.</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LayoutInflaterFactory2Wrapper</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> base: LayoutInflater.Factory2?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> fallback: LayoutInflater.Factory2?,
</span></span><span style=display:flex><span>) : LayoutInflater.Factory2 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreateView</span>(
</span></span><span style=display:flex><span>        parent: View?,
</span></span><span style=display:flex><span>        name: String?,
</span></span><span style=display:flex><span>        context: Context?,
</span></span><span style=display:flex><span>        attrs: AttributeSet?,
</span></span><span style=display:flex><span>    ): View? = base<span style=color:#f92672>?.</span>onCreateView(parent, name, context, attrs)
</span></span><span style=display:flex><span>        <span style=color:#f92672>?:</span> fallback<span style=color:#f92672>?.</span>onCreateView(parent, name, context, attrs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreateView</span>(
</span></span><span style=display:flex><span>        name: String,
</span></span><span style=display:flex><span>        context: Context,
</span></span><span style=display:flex><span>        attrs: AttributeSet?,
</span></span><span style=display:flex><span>    ): View? = onCreateView(<span style=color:#75715e>/* parent = */</span> <span style=color:#66d9ef>null</span>, name, context, attrs)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>Create a new class that extends <code>ContextWrapper</code>, and override the <code>getSystemService</code> method.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyContextWrapper</span>(
</span></span><span style=display:flex><span>    base: Context,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> baseFactory: LayoutInflater.Factory2,
</span></span><span style=display:flex><span>) : ContextWrapper(base) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> inflater: LayoutInflater <span style=color:#66d9ef>by</span> lazy {
</span></span><span style=display:flex><span>        LayoutInflater
</span></span><span style=display:flex><span>            .from(baseContext)
</span></span><span style=display:flex><span>            .cloneInContext(<span style=color:#75715e>/* newContext = */</span> <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>            .apply { factory = LayoutInflaterFactory2Wrapper(baseFactory, factory2) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getSystemService</span>(name: String): Any? =
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LAYOUT_INFLATER_SERVICE <span style=color:#f92672>!=</span> name) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>.getSystemService(name)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            inflater
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>Set your custom <code>ContextWrapper</code> on your <code>Activity</code> .</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivity</span> : AppCompatActivity() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>attachBaseContext</span>(newBase: Context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> factory = MyLayoutInflaterFactory()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> wrapper = MyContextWrapper(newBase, factory)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.attachBaseContext(wrapper);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=fragmentfactory>FragmentFactory<a hidden class=anchor aria-hidden=true href=#fragmentfactory>#</a></h1><p>Starting from <a href=https://developer.android.com/jetpack/androidx/releases/fragment#1.1.0-alpha01>androidx.fragment version 1.1.0-alpha01</a>, you can use the <code>FragmentFactory</code> abstract class to customise the creation of a <code>Fragment</code> instance.</p><p>Here&rsquo;s how you can use it.</p><ol><li>Create a new class that extends <code>FragmentFactory</code>, and override the appropriate methods.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyFragmentFactory</span> : FragmentFactory() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>instantiate</span>(
</span></span><span style=display:flex><span>        classLoader: ClassLoader,
</span></span><span style=display:flex><span>        className: String,
</span></span><span style=display:flex><span>    ): Fragment = <span style=color:#66d9ef>when</span> (className) {
</span></span><span style=display:flex><span>        MyFragment<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java.name <span style=color:#f92672>-&gt;</span> MyFragment()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fallback to Android&#39;s default implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>super</span>.instantiate(classLoader, className)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>Set your custom <code>FragmentFactory</code> instance on your <code>FragmentActivity</code> (or <code>Fragment</code>) before any fragment operations are performed.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyActivity</span> : FragmentActivity() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style=display:flex><span>        supportFragmentManager.fragmentFactory = MyFragmentFactory()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.onCreate(savedInstanceState)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Your activity initialization and logic here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Other overridden methods and custom methods here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=viewmodel>ViewModel<a hidden class=anchor aria-hidden=true href=#viewmodel>#</a></h2><p>Starting from <a href=https://developer.android.com/jetpack/androidx/releases/lifecycle#2.5.0-alpha01>androidx.lifecycle version 2.5.0-alpha01</a>, you can use the <code>ViewModelProvider.Factory</code> with the <code>CreationExtras</code> to simplify the <code>ViewModel</code> creation (for example, <code>SavedStateHandle</code>).</p><p>Here&rsquo;s how you can use it.</p><ol><li>Create a new class that implements <code>ViewModelProvider.Factory</code>, and override the appropriate methods.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyViewModelFactory</span> : ViewModelProvider.Factory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Suppress</span>(<span style=color:#e6db74>&#34;UNCHECKED_CAST&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span> : <span style=color:#a6e22e>ViewModel</span>&gt; <span style=color:#a6e22e>create</span>(
</span></span><span style=display:flex><span>        modelClass: Class&lt;T&gt;,
</span></span><span style=display:flex><span>        extras: CreationExtras,
</span></span><span style=display:flex><span>    ): T = <span style=color:#66d9ef>when</span> (modelClass) {
</span></span><span style=display:flex><span>        MyViewModel<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java <span style=color:#f92672>-&gt;</span> MyViewModel(extras.createSavedStateHandle())
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> error(<span style=color:#e6db74>&#34;Unknown ViewModel class: </span><span style=color:#e6db74>$modelClass</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>as</span> T
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>When you need to create an instance of <code>MyViewModel</code>, use the <code>MyViewModelFactory</code>.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> viewModel <span style=color:#66d9ef>by</span> viewModels { MyViewModelFactory() }
</span></span></code></pre></div><h2 id=workmanager-and-workerfactory>WorkManager and WorkerFactory<a hidden class=anchor aria-hidden=true href=#workmanager-and-workerfactory>#</a></h2><p>Starting from <a href=https://developer.android.com/jetpack/androidx/releases/work#1.0.0-alpha09>androidx.work version 1.0.0-alpha09</a>, you can use the <code>WorkerFactory</code> interface to customise the creation of an <code>Worker</code> instance.</p><p>Here&rsquo;s how you can use it.</p><ol><li><a href=https://developer.android.com/guide/background/persistent/configuration/custom-configuration#remove-default>Remove the default initialiser</a>.</li><li>Create a custom <code>WorkerFactory</code> implementation.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyWorkerFactory</span> : WorkerFactory() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Customize the creation of your worker based on the workerClassName and workerParameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>createWorker</span>(
</span></span><span style=display:flex><span>        appContext: Context,
</span></span><span style=display:flex><span>        workerClassName: String,
</span></span><span style=display:flex><span>        workerParameters: WorkerParameters,
</span></span><span style=display:flex><span>    ): ListenableWorker? = <span style=color:#66d9ef>when</span> (workerClassName) {
</span></span><span style=display:flex><span>        MyWorker<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java.name <span style=color:#f92672>-&gt;</span> MyWorker(appContext, workerParameters),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Return null to fallback to Android&#39;s default implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the <code>createWorker</code> method, you can inspect the <code>workerClassName</code> and <code>workerParameters</code> to determine the appropriate worker instance to create. Return <code>null</code> if you don&rsquo;t want to handle the given <code>workerClassName</code> and let the default factory handle it.</p><ol start=3><li>Set the custom <code>WorkerFactory</code> to WorkManager: In your application&rsquo;s initialisation code, before using WorkManager, set your custom <code>WorkerFactory</code> using <code>Configuration</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> configuration = Configuration.Builder()
</span></span><span style=display:flex><span>    .setWorkerFactory(MyWorkerFactory())
</span></span><span style=display:flex><span>    .build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>WorkManager.initialize(context, configuration)
</span></span></code></pre></div><h1 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h1><p>In conclusion, Android has made notable strides in becoming a DI-friendly framework by introducing various APIs that enable dependency injection.</p><p>The article covered several key APIs used by the two most popular DI frameworks for Android.</p><ul><li><code>AppComponentFactory</code> for customising the instantiation of application components.</li><li><code>LayoutInflater.Factory2</code> and <code>View</code> for customising view inflation.</li><li><code>FragmentFactory</code> for customising fragment creation.</li><li><code>ViewModelProvider.Factory</code> with <code>CreationExtras</code> for simplifying ViewModel creation.</li><li><code>WorkerFactory</code> for customising Worker creation in WorkManager.</li></ul><h1 id=credits>Credits<a hidden class=anchor aria-hidden=true href=#credits>#</a></h1><p>Special thanks to <a href=https://twitter.com/maryte_chietera>Maria Chietera</a>, and <a href=https://twitter.com/deathssouls></a><a href=https://twitter.com/tfcporciuncula>Fred Porciúncula</a> proofread review! 🔍</p><hr><blockquote><p>ℹ️ To stay up to date with my writing, follow me on <a href=https://twitter.com/marcellogalhard>Twitter</a> or <a href=http://androiddev.social/@mg>Mastodon</a>. If you have any questions or I missed something, feel free to reach out to me! ℹ️</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://marcellogalhardo.dev/tags/android/>android</a></li><li><a href=https://marcellogalhardo.dev/tags/kotlin/>kotlin</a></li></ul></footer></article></main><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://marcellogalhardo.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></body></html>