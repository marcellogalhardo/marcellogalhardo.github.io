<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Marcello Galhardo</title><link>https://marcellogalhardo.dev/</link><description>Marcello Galhardo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 05 Feb 2021 09:02:50 +0100</lastBuildDate><atom:link href="https://marcellogalhardo.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>N26 Path to Anvil</title><link>https://marcellogalhardo.dev/blog/2021/02/05/n26-path-to-anvil/</link><pubDate>Fri, 05 Feb 2021 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/blog/2021/02/05/n26-path-to-anvil/</guid><description>&lt;p>This post represents my personal experience while working at N26. I do not speak for the company nor by other employees.&lt;/p>
&lt;p>N26 Android App current codebase has a million lines of code, 280+ modules, and 30+ engineers working in 4 different countries and different timezones in a mono repository. Our modules are divided into features and libraries, and we have been using &amp;ldquo;&lt;a href="https://cashapp.github.io/2020-08-25/attacking-build-times-with-sample-apps">Sample Apps&lt;/a>&amp;rdquo; for years now as our full app build time might take up to 20 minutes.&lt;/p>
&lt;p>Today I will share a little about my story with Dagger inside the company, why we adopt Anvil, some of the challenges we faced, and how are the results so far.&lt;/p>
&lt;h1 id="dagger-oh-my">Dagger, (oh, my)&lt;/h1>
&lt;p>N26 has a long history with Dagger. We have been using it for years, we developed our customizations and libraries on top of it, and many of our architectural decisions were made relying on Dagger features.&lt;/p>
&lt;p>Dagger is excellent but comes with a price when used with Kotlin. The more we grew, the more we were charged. Stub generation issues, slow build time, increasing boilerplate to wire &lt;code>@dagger.Component&lt;/code>, new joiners avoided touching the graphs due to complexity&amp;hellip;&lt;/p>
&lt;p>Looking for solutions, we found &lt;a href="https://dagger.dev/hilt/">Hilt by Google&lt;/a>. We enjoyed many of the ideas they proposed as the &lt;a href="https://dagger.dev/hilt/monolithic.html">Monolithic Component&lt;/a> and the &lt;a href="https://dagger.dev/hilt/testing.html">testing philosophy&lt;/a>. But the trade-off was not that good for us: a migration would be painful and would take months to years, to not say we did not appreciate the byte code manipulation and the extra KAPT processor.&lt;/p>
&lt;p>Simultaneously, another solution appeared, which solved some of the same problems differently: &lt;a href="https://github.com/square/anvil">Anvil&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>Anvil is a Kotlin compiler plugin to make dependency injection with Dagger easier by automatically merging Dagger modules and component interfaces.&lt;/p>
&lt;/blockquote>
&lt;h1 id="sharpening-your-blade">Sharpening your blade&lt;/h1>
&lt;p>To get an idea of how Anvil would affect us, we started with a set of experiments. The first one would be to wire a few modules while keeping backward compatibility without impacting any feature developer. In a matter of hours, we managed to conclude it. In a week, we had many modules using Anvil. We did not identify any expressive build time impact.&lt;/p>
&lt;p>We were happy with the result. We decided to be more ambitious: we selected our code base&amp;rsquo;s prominent monolith module to fully migrated to Anvil, and afterward, we broke this monolith apart into small libraries. It took us a few months to complete the goal, but we succeeded and did not identify any expressive build time impact, again.&lt;/p>
&lt;p>To be sure we were on the right path, we mapped the relationship of a few of our most complex modules before and after adopting Anvil. For a matter of company&amp;rsquo;s privacy, all text is blurred, but you can still see the positive impact by noting the arrows:&lt;/p>
&lt;p>&lt;img src="https://dev-to-uploads.s3.amazonaws.com/i/5mwhivwsc02r0w8z8rrx.png" alt="Before and After">&lt;/p>
&lt;p>Finally, we decided to go full Anvil: we turned on &lt;a href="https://github.com/square/anvil#dagger-factory-generation">Anvil&amp;rsquo;s Dagger Factory generation&lt;/a> in all modules that we could (20+ at the time). We identified build times improvements of ~50% for individual modules build times, ~10% for Sample Apps, and because Anvil does not rely on KAPT, we never saw any KAPT issue again on those modules.&lt;/p>
&lt;p>&lt;img src="https://dev-to-uploads.s3.amazonaws.com/i/pozrcji1hz1w6kn5vcj7.png" alt="Benchmark">&lt;/p>
&lt;p>Many improvements, but we believed we could take it further: let&amp;rsquo;s take the good things from Hilt and bring it to Anvil.&lt;/p>
&lt;h1 id="hilt-to-anvil">Hilt to Anvil&lt;/h1>
&lt;p>We decided to adopt what we like from Hilt while using Anvil.&lt;/p>
&lt;p>The first point was to provide a single monolith component, and for that, we started to merge the components and use Anvil&amp;rsquo;s &lt;code>@ContributesTo&lt;/code> to binding the modules instead. It took quite some time, it was challenging but it worked well.&lt;/p>
&lt;p>The second one was to support some Jetpack Libraries. We started with &lt;code>FragmentFactory&lt;/code> to leverage the constructor injector as much as possible. We created a &lt;code>@FragmentKey&lt;/code> and used Dagger&amp;rsquo;s multi-binding to wire everything. Here is how the code might look like:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#a6e22e">@ContributesBinding&lt;/span>(Singleton&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>, FragmentFactory&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultibindingFragmentFactory&lt;/span> &lt;span style="color:#a6e22e">@Inject&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> map: Map&amp;lt;Class&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> Fragment&amp;gt;, &lt;span style="color:#a6e22e">@JvmSuppressWildcards&lt;/span> Provider&amp;lt;Fragment&amp;gt;&amp;gt;
) : FragmentFactory() {
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">instantiate&lt;/span>(classLoader: ClassLoader, className: String): Fragment {
&lt;span style="color:#66d9ef">val&lt;/span> fragmentClass = loadFragmentClass(classLoader, className)
&lt;span style="color:#66d9ef">return&lt;/span> map[fragmentClass]&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">get&lt;/span>() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.instantiate(classLoader, className)
}
}
&lt;span style="color:#a6e22e">@Target&lt;/span>(
AnnotationTarget.CLASS,
AnnotationTarget.FUNCTION
)
&lt;span style="color:#a6e22e">@Retention&lt;/span>(value = AnnotationRetention.RUNTIME)
&lt;span style="color:#a6e22e">@MapKey&lt;/span>
&lt;span style="color:#66d9ef">annotation&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FragmentKey&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: KClass&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> Fragment&amp;gt;)
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Activity&lt;/span> : AppCompatActivity() {
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> component: MainComponent
&lt;span style="color:#66d9ef">get&lt;/span>() = TODO(&lt;span style="color:#e6db74">&amp;#34;Retrieve your Monolith Component&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">onCreate&lt;/span>(savedInstanceState: Bundle?) {
supportFragmentManager.fragmentFactory = component.getFragmentFactory()
&lt;span style="color:#66d9ef">super&lt;/span>.onCreate(savedInstanceState)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now to wire your &lt;code>Fragment&lt;/code>, you can simple:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#a6e22e">@ContributesMultibinding&lt;/span>(Singleton&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)
&lt;span style="color:#a6e22e">@FragmentKey&lt;/span>(HomeFragment&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HomeFragment&lt;/span> &lt;span style="color:#a6e22e">@Inject&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;span style="color:#75715e">// Dependencies goes here. :)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>) : Fragment()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more details around Fragments, check the &lt;a href="https://developer.android.com/guide/fragments">official guide&lt;/a>.&lt;/p>
&lt;p>Having a Monolith Component and relying on Fragment&amp;rsquo;s constructor injector means we can invoke any fragment from any place of our application, and things &amp;ldquo;will work&amp;rdquo;. Scoping becomes intuitive for those classes. If you inject an object in the &lt;code>Fragment&lt;/code> is a fragment scope, if you inject into the &lt;code>ViewModel&lt;/code> is a view model scope. We also offer a &lt;code>SessionScope&lt;/code> and &lt;code>Singleton&lt;/code> scope.&lt;/p>
&lt;p>For &lt;code>ViewModels&lt;/code> a simple &lt;code>Provider&amp;lt;ViewModel&amp;gt;&lt;/code> or &lt;code>AssistedInject&lt;/code>, if you need an instance of &lt;code>SavedStateHandle&lt;/code>, will do the trick.&lt;/p>
&lt;p>And finally, testing: Anvil offers a &lt;a href="https://github.com/square/anvil#exclusions">replace module feature&lt;/a> that is handful to provide new dependencies during tests. For that, we create helper modules called &lt;code>testing&lt;/code> and we provide fake dependencies of those replacing the production modules. Developers that include the &lt;code>testing&lt;/code> in their test classpath can automatically interact with our testing utilities (or create their own, if required). To be completely honest here, it is more of an ongoing process.&lt;/p>
&lt;p>&lt;img src="https://dev-to-uploads.s3.amazonaws.com/i/qy6625r4e0n4qucacvtm.png" alt="General Structure">&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>Anvil is a robust and straightforward solution. It does what it suppose to do and does it well. It benefits from a seamless synergy with Dagger, while not being opinionated and letting you decide how you integrate with other libraries (or not integrating it at all).&lt;/p>
&lt;p>Also, the fact it does not rely on KAPT is a &lt;strong>tremendous advantage&lt;/strong> for large projects and should be kept in mind while deciding between Anvil or Hilt. I&amp;rsquo;m delighted with the overall experience, and I enjoy seeing how many feature developers started to migrate away from KAPT to Anvil proactively:&lt;/p>
&lt;p>&lt;img src="https://dev-to-uploads.s3.amazonaws.com/i/g1w7vh4g3sylpkl2syyd.png" alt="Kill KAPT">&lt;/p>
&lt;p>Finally, as you can see above, many of the Hilt&amp;rsquo;s features can be implemented in Anvil. However, it is vital to keep in mind Anvil is not a silver bullet. It is essential to have people in your team that understand Dagger and Dependency Injection to build the integrations you might need.&lt;/p>
&lt;h1 id="update-20210225">Update 2021.02.25&lt;/h1>
&lt;p>As many people reached out asking advice on how to implement some Hilt features (e.g., ViewModelScope, SavedStateHandle, and others), I created a &lt;a href="https://github.com/marcellogalhardo/hilt-to-anvil">small showcase project&lt;/a>.&lt;/p>
&lt;h1 id="update-20210319">Update 2021.03.19&lt;/h1>
&lt;p>Updated &lt;code>MultibindingFragmentFactory&lt;/code> example and &lt;a href="https://github.com/marcellogalhardo/hilt-to-anvil">showcase project&lt;/a> to use new &lt;code>@ContributesMultibinding&lt;/code> from &lt;a href="https://github.com/square/anvil/releases/tag/v2.2.0">Anvil 2.2.0&lt;/a>.&lt;/p>
&lt;h1 id="credits">Credits&lt;/h1>
&lt;p>Thanks to &lt;a href="https://twitter.com/maryte_chietera">Maria Chietera&lt;/a>, &lt;a href="https://twitter.com/orafaaraujo">Rafael Araujo&lt;/a>, &lt;a href="https://twitter.com/laggedHero">Tiago Cunha&lt;/a>, &lt;a href="https://twitter.com/fabiocarballo">Fabio Carballo&lt;/a>, and &lt;a href="https://twitter.com/s_anastasov">Stojan Anastasov&lt;/a> proofread review! ðŸ”&lt;/p>
&lt;p>And a special thank you to &lt;a href="https://twitter.com/vRallev">Ralf Wondratschek&lt;/a> for early feedback and creating Anvil! :knife:&lt;/p>
&lt;p>If you like my posts, follow me on Twitter: &lt;a href="https://twitter.com/marcellogalhard">@marcellogalhard&lt;/a>&lt;/p></description></item><item><title>Humble Views Proud ViewModels</title><link>https://marcellogalhardo.dev/blog/2021/02/01/humble-views-proud-viewmodels/</link><pubDate>Mon, 01 Feb 2021 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/blog/2021/02/01/humble-views-proud-viewmodels/</guid><description>&lt;p>The Android Community has long advocated that Activities and Fragments were viewsâ€Š - â€Šbut this perception has changed over time. For good. Let&amp;rsquo;s dive deep into how to design views and view models, how they wire to a LifecycleOwner, and how this can positively impact your&amp;rsquo;s app testability.&lt;/p>
&lt;p>&lt;img src="https://dev-to-uploads.s3.amazonaws.com/i/vh4on41q7srqns01vp9r.png" alt="Sign-Up Form">&lt;/p>
&lt;p>To better describe how to build humble views we will be developing an elementary Sign-Up form with an email, a password text field and two buttons: a cancel that pops the user&amp;rsquo;s back stack and a sign up that creates an account and moves the user to the home screen.&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://medium.com/r?url=https%3A%2F%2Fnetflixtechblog.com%2Fmaking-our-android-studio-apps-reactive-with-ui-components-redux-5e37aac3b244">&amp;ldquo;Fragment is not your View&amp;rdquo;â€Š-â€ŠJuliano Moraes&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Heads-up:&lt;/strong> this article expects you to be familiar with Dependency Injection (but no particular framework), Coroutines, Fragment, and View Binding. I won&amp;rsquo;t use Jetpack&amp;rsquo;s ViewModel, but the code here is entirely compatible. I will not cover any other aspects outside humble Views and ViewModels.&lt;/p>
&lt;h1 id="views">Views&lt;/h1>
&lt;p>&lt;code>View&lt;/code>s represent your UI. They can be written in code or, the most common way, using XML. Android views can not have a custom constructor as they must be created by the OS using reflection when inflating it from XML, during a configuration change, or process death.&lt;/p>
&lt;p>&lt;code>View&lt;/code>s should not be aware of your architecture decisions. If you use MVP, MVC, MVVM, or MVI is irrelevant for a well-designed view.&lt;/p>
&lt;p>&lt;code>View&lt;/code>s are hard to test and require an Instrumentation or Robolectric environment, which makes them slow. For that reason, we might want our views to be a &lt;a href="https://martinfowler.com/bliki/HumbleObject.html">Humble Object&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpView&lt;/span> &lt;span style="color:#a6e22e">@JvmOverloads&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
context: Context,
attrs: AttributeSet? = &lt;span style="color:#66d9ef">null&lt;/span>
) : ConstraintLayout(context, attrs) {
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> binding = SignUpViewBinding.inflate(LayoutInflater.from(context), &lt;span style="color:#66d9ef">this&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> email: String
&lt;span style="color:#66d9ef">get&lt;/span>() = binding.email.text
&lt;span style="color:#66d9ef">set&lt;/span>(value) { binding.email.setText(value) }
&lt;span style="color:#66d9ef">var&lt;/span> password: String
&lt;span style="color:#66d9ef">get&lt;/span>() = binding.email.text
&lt;span style="color:#66d9ef">set&lt;/span>(value) { binding.email.setText(value) }
&lt;span style="color:#66d9ef">var&lt;/span> isSignUpEnabled: Boolean
&lt;span style="color:#66d9ef">get&lt;/span>() = binding.signUpButton.isEnabled
&lt;span style="color:#66d9ef">set&lt;/span>(value) { binding.signUpButton.isEnabled = value }
&lt;span style="color:#66d9ef">var&lt;/span> onSignUpClicked: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {}
&lt;span style="color:#66d9ef">var&lt;/span> onCancelClicked: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {}
&lt;span style="color:#66d9ef">var&lt;/span> onEmailChanged: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {}
&lt;span style="color:#66d9ef">var&lt;/span> onPasswordChanged: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {}
&lt;span style="color:#66d9ef">init&lt;/span> {
binding.signUpButton.setOnClickListener { onSignUpClicked() }
binding.onCancelClicked.setOnClickListener { onCancelClicked() }
binding.email.doOnTextChanged { text, _, _, _ &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
onEmailChanged(text)
}
binding.password.doOnTextChanged { text, _, _, _ &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
onPasswordChanged(text)
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="what-is-going-on-with-this-viewbinding">What is going on with this ViewBinding?&lt;/h4>
&lt;p>In my &lt;code>View&lt;/code>&amp;rsquo;s XML root, I use a &lt;code>&amp;lt;merge&amp;gt;&lt;/code> tag, and &lt;code>ViewBinding&lt;/code> understands that: it provides me with an inflate function that attaches the view automatically to its parent.&lt;/p>
&lt;h1 id="viewmodels">ViewModels&lt;/h1>
&lt;p>&lt;code>ViewModel&lt;/code>&amp;rsquo;s are a lightweight representation of your UI. The &lt;code>ViewModel&lt;/code> is responsible for coordinating any user interaction to any business model required. It may offer a one or two-way binding to let those business models interact with the GUI.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewModel&lt;/span>(
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> savedStateHandle: SavedStateHandle,
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope: CoroutineScope,
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: SignUpRepository,
) {
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _navigation = Channel&amp;lt;Navigation&amp;gt;()
&lt;span style="color:#66d9ef">val&lt;/span> navigation = _navigation.receiveAsFlow()
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _toastMessage = Channel&amp;lt;ToastMessage&amp;gt;()
&lt;span style="color:#66d9ef">val&lt;/span> toastMessage = _toastMessage.receiveAsFlow()
&lt;span style="color:#66d9ef">val&lt;/span> email = savedStateHandle.getStateFlow&amp;lt;String&amp;gt;(scope, &lt;span style="color:#e6db74">&amp;#34;email&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">val&lt;/span> password = savedStateHandle.getStateFlow&amp;lt;String&amp;gt;(scope, &lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _isSignUpEnabled = savedStateHandle.getStateFlow&amp;lt;Boolean&amp;gt;(scope, &lt;span style="color:#e6db74">&amp;#34;isSignUpEnabled&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;span style="color:#66d9ef">val&lt;/span> isSignUpEnabled = _isSignUpEnabled.asStateFlow()
&lt;span style="color:#66d9ef">init&lt;/span> {
email.collectIn(scope) { updateSignUpEnabled() }
password.collectIn(scope) { updateSignUpEnabled() }
}
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">onSignUpClicked&lt;/span>() {
runCatching {
&lt;span style="color:#75715e">// Try to parse e-mail and validate password. If yes, save.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> email: String = &lt;span style="color:#75715e">// parse e-mail.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> password: String = &lt;span style="color:#75715e">// verify if password is acceptable.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> repository.signUp(email, password)
}.fold(
onSuccess = { _navigation.sendIn(scope, Navigation.Push(SignUpRoutes.Home)) },
onFailure = { _toastMessage.sendIn(scope, ToastMessage(R.string.generic_error)) },
)
}
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">onCancelClicked&lt;/span>() {
_navigation.sendIn(scope, Navigation.Pop)
}
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateSignUpEnabled&lt;/span>() {
&lt;span style="color:#75715e">// Naive logic to enable sign up.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> _isSignUpEnabled = email.isNotBlank() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> password.isNotBlank()
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="why-expose-some-flows-as-mutablestateflow-and-othersno">Why expose some flows as MutableStateFlow and othersÂ no?&lt;/h4>
&lt;p>Each field has a different requirement: two-way or one-way binding.&lt;/p>
&lt;p>TextFields requires a two-way binding as we want to get updates when the user types a new content while preserving the ability to update its content whenever necessary. Exposing it as a &lt;code>MutableStateFlow&lt;/code> allows us to move all sanitization logic to the view model (see &lt;code>onSignUpClicked&lt;/code>) and ensure the View is as humble as possible.&lt;/p>
&lt;p>The sign-up button state requires a one-way binding (see &lt;code>isSignUpEnabled&lt;/code>)â€Š - â€Šonly the &lt;code>ViewModel&lt;/code> can change its state based in a validation logic.&lt;/p>
&lt;h4 id="why-not-modeling-my-ui-state-as-a-single-flow-in-the-viewmodel">Why not modeling my UI State as a single flow in the ViewModel?&lt;/h4>
&lt;p>The concepts here do not exclude a single view state, I believe they complement each other.&lt;/p>
&lt;p>You can easily keep your view humble while modeling UI State as a single object on top of the ViewModel. In this case, the &lt;code>ViewModel&lt;/code> would be responsible for handling the unidirectional data flow and doing the required diffs between each state emission within your bindings to enforce your UI is not being updated without demand. Therefore, let your view humble allow you to keep it agnostic of how you handle state, architecture decisions, and it enable you to test your &lt;code>ViewModel&lt;/code> and classes above it as a unit very closely of how it would behave in the real world with a GUI: remember, the &lt;code>View&lt;/code> is humble!&lt;/p>
&lt;p>I will not cover these concepts here but for a better understanding of why you would like to model your UI State as a single sealed hierarchy and how to do it well, I highly recommend my friend&amp;rsquo;s &lt;a href="https://twitter.com/s_anastasov">Stojan Anastasov&lt;/a> post about the subject: &lt;a href="https://lordraydenmk.github.io/2021/modelling-ui-state/">Modeling UI State&lt;/a>.&lt;/p>
&lt;h1 id="lifecycleowner">LifecycleOwner&lt;/h1>
&lt;p>The UI Controller. Usually, a &lt;code>Fragment&lt;/code> responsible for a section of the screen. A &lt;code>LifecycleOwner&lt;/code> is responsible to wire up a &lt;code>View&lt;/code> to a &lt;code>ViewModel&lt;/code>, delegate callbacks from the Android OS, handle configuration changes and more.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpFragment&lt;/span> : Fragment() {
&lt;span style="color:#75715e">// Retain the instance across configuration changes.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> viewModel &lt;span style="color:#66d9ef">by&lt;/span> retain { entry &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> repository: SignUpRepository = &lt;span style="color:#75715e">// creates the repository
&lt;/span>&lt;span style="color:#75715e">&lt;/span> SignUpViewModel(entry.savedStateHandle, entry.scope, repository)
}
&lt;span style="color:#75715e">// Creates your View and connects to the ViewModel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">onCreateView&lt;/span>(
inflater: LayoutInflater,
container: ViewGroup?,
savedInstanceState: Bundle?
): View? {
&lt;span style="color:#66d9ef">val&lt;/span> view = SignUpView(requireContext())
&lt;span style="color:#75715e">// Bind the View and ViewModel
&lt;/span>&lt;span style="color:#75715e">&lt;/span> view.onSignUpClicked = viewModel&lt;span style="color:#f92672">::&lt;/span>onSignUpClicked
view.onCancelClicked = viewModel&lt;span style="color:#f92672">::&lt;/span>onCancelClicked
viewModel.email.observeIn(viewLifecycleOwner, view&lt;span style="color:#f92672">::&lt;/span>email&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">set&lt;/span>)
viewModel.password.observeIn(viewLifecycleOwner, view&lt;span style="color:#f92672">::&lt;/span>password&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">set&lt;/span>)
viewModel.isSignUpEnabled.observeIn(viewLifecycleOwner, view&lt;span style="color:#f92672">::&lt;/span>isSignUpEnabled&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">set&lt;/span>)
&lt;span style="color:#75715e">// Other binds you might need with the view...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> viewModel.navigation.observeIn(viewLifecycleOwner) { navigation &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#75715e">// Handle navigation.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
viewModel.toastMessage.observeIn(viewLifecycleOwner) { message &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#75715e">// Handle toast message.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#66d9ef">return&lt;/span> view
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="testing">Testing&lt;/h1>
&lt;p>We designed our View as a Humble Object to let us quickly test both &lt;code>View&lt;/code> and &lt;code>ViewModel&lt;/code>. As you might have perceived, the &lt;code>ViewModel&lt;/code> is straightforward to write tests as we do not depend on any Android related class.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewModelTest&lt;/span> {
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = TestCoroutineScope()
&lt;span style="color:#75715e">// A fake version of the data source to not cross boundaries like network and database.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> dataSource = TestDataSource()
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createSut&lt;/span>(): SignUpViewModel {
&lt;span style="color:#66d9ef">return&lt;/span> SignUpViewModel(SavedStateHandle(), scope, SignUpRepository(dataSource))
}
&lt;span style="color:#75715e">// Set up, tear down, other tests, etc...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">`given email and password field is not blank when signing up then navigate to the home`&lt;/span> {
&lt;span style="color:#75715e">// Arrange Phase
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> sut = createSut().apply {
email = &lt;span style="color:#e6db74">&amp;#34;my.fake.person@gmail.com&amp;#34;&lt;/span>
password = &lt;span style="color:#e6db74">&amp;#34;8S#@2LAaB_.NJh(Y&amp;#34;&lt;/span>
}
&lt;span style="color:#66d9ef">var&lt;/span> actualNavigation: Navigation? = &lt;span style="color:#66d9ef">null&lt;/span>
scope.launch { sut.navigation.collect { actualNavigation = &lt;span style="color:#66d9ef">it&lt;/span> } }
&lt;span style="color:#75715e">// Act Phase
&lt;/span>&lt;span style="color:#75715e">&lt;/span> sut.onSignUpClicked()
&lt;span style="color:#75715e">// Assert Phase
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> expectedNavigation = Navigation.Push(SignUpRoutes.Home)
assertThat(actualNavigation).isEqualTo(expectedNavigation)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As the view is a humble object, there is nothing much to test on it. However, we might want to ensure that the UI behaves as expected when the &lt;code>ViewModel&lt;/code> changes its attributes. For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewTest&lt;/span> {
&lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">`given sign up is disabled then the button should not be clickable`&lt;/span>() {
launchViewInFragment { SignUpView(requireContext()) }
.onView { &lt;span style="color:#66d9ef">it&lt;/span>.isSignUpEnabled = &lt;span style="color:#66d9ef">false&lt;/span> }
onView(withId(R.id.signUpButton))
.check(matches(not(isEnabled())))
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>It is relatively easy to see that &lt;code>View&lt;/code>&amp;rsquo;s, in Android, are strongly tied to the concept of their functionality. Humble View&amp;rsquo;s is a way to create a clear separation between them and the Android Framework aiming for scalability, readability, and maybe the most essential point, testing.&lt;/p>
&lt;p>In this article, we applied Humble Object pattern and MVVM concepts to create the circumstances that would allow developers to test &lt;code>View&lt;/code>&amp;rsquo;s and &lt;code>ViewModel&lt;/code>&amp;rsquo;s with ease even when they are strongly tied conceptually. Additionally, understanding that the &lt;code>LifecycleOwner&lt;/code> is not your &lt;code>View&lt;/code> will help you to ensure your code is highly testable.&lt;/p>
&lt;p>Other than testing, projects that use this approach can easily compose more complex &lt;code>View&lt;/code>&amp;rsquo;s, and &lt;code>ViewModel&lt;/code>&amp;rsquo;s, from smaller objects. Lastly, this approach fit with Jetpack&amp;rsquo;s Compose: replace the &lt;code>View&lt;/code> with a &lt;code>@Composable&lt;/code> and reuse the &lt;code>ViewModel&lt;/code>!&lt;/p>
&lt;p>&lt;strong>Happy Coding!&lt;/strong> ðŸ˜Ž&lt;/p>
&lt;h1 id="helper-functions--credits">Helper functions &amp;amp; credits!&lt;/h1>
&lt;p>I used &lt;a href="http://github.com/marcellogalhardo/retained">Retained&lt;/a> library to keep the state of the &lt;code>ViewModel&lt;/code> in configuration changes. I also published all the helper functions as &lt;a href="https://gist.github.com/marcellogalhardo/a9985f7b3875fa41c379a2ba65d8ac9c">Github GISTs&lt;/a>, so you can use them as you please.&lt;/p>
&lt;p>Special thanks to &lt;a href="https://twitter.com/maryte_chietera">Maria Chietera&lt;/a>, &lt;a href="https://twitter.com/TiagoDvl">Tiago DÃ¡vila&lt;/a>, &lt;a href="https://twitter.com/orafaaraujo">Rafael Araujo&lt;/a>, &lt;a href="https://twitter.com/laggedHero">Tiago Cunha&lt;/a>, &lt;a href="https://twitter.com/felipeapedroso">Felipe Pedroso&lt;/a>, and &lt;a href="https://twitter.com/s_anastasov">Stojan Anastasov&lt;/a> proofread review! ðŸ”&lt;/p>
&lt;p>If you like my posts, follow me on Twitter: &lt;a href="https://twitter.com/marcellogalhard">@marcellogalhard&lt;/a>&lt;/p></description></item><item><title>Factory Methods in Kotlin</title><link>https://marcellogalhardo.dev/blog/2020/02/01/factory-methods-in-kotlin/</link><pubDate>Sat, 01 Feb 2020 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/blog/2020/02/01/factory-methods-in-kotlin/</guid><description>&lt;p>When talking about Factory Methods extension functions tends to be favored in Kotlin - but it might be a challenge to name these functions in a discoverable way without polluting your classpath. Therefore, we can get inspiration on Kotlin&amp;rsquo;s Standard library to improve our naming.&lt;/p>
&lt;h2 id="wrapping-an-instance">Wrapping an instance&lt;/h2>
&lt;p>If your intention is to get a given instance, for example &lt;code>javax.inject.Provider&lt;/code>, create an instance of &lt;code>ViewModelProvider.Factory&lt;/code> which internally uses it: you want a wrapper. Looking inside Kotlin&amp;rsquo;s Standard library we can find &lt;a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-executor.html">asExecutor&lt;/a> which does exactly the same.&lt;/p>
&lt;p>That said, a good way of doing it is:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">VM&lt;/span> : &lt;span style="color:#a6e22e">ViewModel&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Provider&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> VM&amp;gt;.asViewModelFactory(): ViewModelProvider.Factory {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">ViewModelProvider&lt;/span>.Factory {
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">ViewModel&lt;/span>?&amp;gt; &lt;span style="color:#a6e22e">create&lt;/span>(modelClass: Class&amp;lt;T&amp;gt;): T {
&lt;span style="color:#a6e22e">@Suppress&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;UNCHECKED_CAST&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">get&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> T
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mapping-data">Mapping data&lt;/h2>
&lt;p>When your intention is to copy the data of a given instance, for example &lt;code>UserDto&lt;/code>, into a new instance like &lt;code>User&lt;/code> (domain model): you want a mapper. Again, Kotlin&amp;rsquo;s Standard library give us a good example with &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/to-list.html?_ga=2.130355144.672183661.1577982073-802284527.1577800392">toList&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">UserDto&lt;/span>.toUser(): User {
&lt;span style="color:#66d9ef">return&lt;/span> User(
name = Name(
first = &lt;span style="color:#66d9ef">this&lt;/span>.firstName,
last = &lt;span style="color:#66d9ef">this&lt;/span>.lastName
),
email = Email(&lt;span style="color:#66d9ef">this&lt;/span>.email)
age = &lt;span style="color:#66d9ef">this&lt;/span>.age
)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="vararg-constructors">Vararg constructors&lt;/h2>
&lt;p>Maybe you want to provide a secondary constructor which accept a vararg of that list of parameters but you don&amp;rsquo;t want to pollute your class code which such a small and optional thing. Kotlin&amp;rsquo;s Standard Library offer us the convenient &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html?_ga=2.139095028.672183661.1577982073-802284527.1577800392">listOf&lt;/a> as an example.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">Controller&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">compositeControllerOf&lt;/span>(&lt;span style="color:#66d9ef">vararg&lt;/span> providers: Provider&amp;lt;T&amp;gt;) =
CompositeControllerFactory(providers.toList())
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="builders">Builders&lt;/h2>
&lt;p>Last but not least, Kotlin&amp;rsquo;s constructor combined with named parameter covers most use cases of the Builder Design Pattern. However, sometimes you might want to create an instance which constructors are not suitable - for example, with a lot of optionals and configurable attributes where you want to provide alternative combinations (maybe accepting URL or URI). For that cases, we can use &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/build-string.html">buildString&lt;/a> as an example.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">buildImageLoader&lt;/span>(
builderAction: ImageLoaderBuilder.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit
): String
&lt;span style="color:#75715e">// usage example
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#66d9ef">val&lt;/span> validUri = &lt;span style="color:#75715e">// receives a valid URI object
&lt;/span>&lt;span style="color:#75715e">&lt;/span> buildImageLoader {
uri = validUri
loadingPlaceholder = R.drawable.loading_placeholder
errorPlaceholder = R.drawable.error_placeholder
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>As you can see, the Kotlin Standard library can be a good source of inspiration when designing code aiming for better discoverability between Kotlin Developers through the consistent pattern the language follows. Why not take advantage of that?&lt;/p></description></item><item><title>Dagger, ViewModels and Fragments</title><link>https://marcellogalhardo.dev/blog/2020/01/01/dagger-viewmodels-and-fragments/</link><pubDate>Wed, 01 Jan 2020 09:02:50 +0100</pubDate><guid>https://marcellogalhardo.dev/blog/2020/01/01/dagger-viewmodels-and-fragments/</guid><description>&lt;p>Dagger is a powerful DI framework but when combined with Architecture Components from Android it might cause some boilerplate: mainly when using ViewModels and Fragments with constructor injection.&lt;/p>
&lt;p>Kotlin offers many options to deal with this boilerplate in an elegante way for simple use cases.&lt;/p>
&lt;h4 id="viewmodelproviderfactory">ViewModelProvider.Factory&lt;/h4>
&lt;p>Dagger allows you to inject the &lt;a href="https://docs.oracle.com/javaee/6/api/javax/inject/Provider.html">Provider&lt;/a> of any type available on the dependency graph and this provider can be easily mapped to ViewModelProvider.Factory.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// ViewModelFactory.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * Creates a [ViewModelProvider.Factory] that wraps the original ViewModel [Provider].
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">VM&lt;/span> : &lt;span style="color:#a6e22e">ViewModel&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Provider&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> VM&amp;gt;.asViewModelFactory(): ViewModelProvider.Factory {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">ViewModelProvider&lt;/span>.Factory {
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">ViewModel&lt;/span>?&amp;gt; &lt;span style="color:#a6e22e">create&lt;/span>(modelClass: Class&amp;lt;T&amp;gt;): T {
&lt;span style="color:#a6e22e">@Suppress&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;UNCHECKED_CAST&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">get&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> T
}
}
}
&lt;span style="color:#75715e">// MyActivity.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyActivity&lt;/span> : AppCompatActivity() {
&lt;span style="color:#a6e22e">@Inject&lt;/span>
&lt;span style="color:#66d9ef">lateinit&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> viewModelProvider: Provider&amp;lt;MyViewModel&amp;gt;
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> viewModel &lt;span style="color:#66d9ef">by&lt;/span> viewModels&amp;lt;MyViewModel&amp;gt; { viewModelProvider.asViewModelFactory() }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="composable-viewmodelproviderfactory">Composable ViewModelProvider.Factory&lt;/h5>
&lt;p>However, sometimes a single ViewModelProvider.Factory is not enough and a composable approach might be needed. Luckly, Dagger also allows you to easily accomplish that.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// ViewModelFactory.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">typealias&lt;/span> ViewModelProviderMap = Map&amp;lt;Class&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> ViewModel&amp;gt;, &lt;span style="color:#a6e22e">@JvmSuppressWildcards&lt;/span> Provider&amp;lt;ViewModel&amp;gt;&amp;gt;
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * A [ViewModelProvider.Factory] that can hold onto multiple other ViewModel [Provider]&amp;#39;s.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Note this was designed to be used with [ViewModelKey].
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CompositeViewModelFactory&lt;/span> &lt;span style="color:#a6e22e">@Inject&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> map: ViewModelProviderMap
) : ViewModelProvider.Factory {
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">ViewModel&lt;/span>?&amp;gt; &lt;span style="color:#a6e22e">create&lt;/span>(modelClass: Class&amp;lt;T&amp;gt;): T {
&lt;span style="color:#a6e22e">@Suppress&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;UNCHECKED_CAST&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> map[modelClass]&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">get&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> T
&lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${modelClass.name}&lt;/span>&lt;span style="color:#e6db74"> cannot be provided without an @Inject constructor or from an @Provides-annotated method. Check your @IntoMap and @ClassKey provider.&amp;#34;&lt;/span>)
}
}
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * A [MapKey] annotation for maps with [KClass] of [ViewModel] keys.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Note this was designed to be used only with [CompositeViewModelFactory].
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>(
AnnotationTarget.FUNCTION,
AnnotationTarget.PROPERTY_GETTER,
AnnotationTarget.PROPERTY_SETTER
)
&lt;span style="color:#a6e22e">@Retention&lt;/span>(value = AnnotationRetention.RUNTIME)
&lt;span style="color:#a6e22e">@MapKey&lt;/span>
&lt;span style="color:#66d9ef">annotation&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ViewModelKey&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: KClass&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> ViewModel&amp;gt;)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, you must do some extra setup to use the CompositeViewModelFactory in your components:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// ViewModelFactoryModule.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@Module&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ViewModelFactoryModule&lt;/span> {
&lt;span style="color:#a6e22e">@Binds&lt;/span>
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">provideViewModelFactory&lt;/span>(impl: CompositeViewModelFactory): ViewModelProvider.Factory
&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>[Binds &lt;span style="color:#a6e22e">@IntoMap&lt;/span> &lt;span style="color:#a6e22e">@ViewModelKey&lt;/span>(MyViewModel1&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)]
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">provideViewModel&lt;/span>(impl: MyViewModel1): MyViewModel1
&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>[Binds &lt;span style="color:#a6e22e">@IntoMap&lt;/span> &lt;span style="color:#a6e22e">@ViewModelKey&lt;/span>(MyViewModel2&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)]
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">provideViewModel&lt;/span>(impl: MyViewModel2): MyViewModel2
}
&lt;span style="color:#75715e">// MyActivity.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyActivity&lt;/span> : AppCompatActivity() {
&lt;span style="color:#a6e22e">@Inject&lt;/span>
&lt;span style="color:#66d9ef">lateinit&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> viewModelFactory: ViewModelProvider.Factory &lt;span style="color:#75715e">// no need for a specific VM.Factory
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> viewModel1 &lt;span style="color:#66d9ef">by&lt;/span> viewModels&amp;lt;MyViewModel1&amp;gt; { viewModelFactory }
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> viewModel2 &lt;span style="color:#66d9ef">by&lt;/span> viewModels&amp;lt;MyViewModel2&amp;gt; { viewModelFactory }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="fragmentfactory">FragmentFactory&lt;/h3>
&lt;p>The same idea can be applied to FragmentFactories for both single and composable versions.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// FragmentFactory.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * Creates a [ViewModelProvider.Factory] that wraps the original ViewModel [Provider].
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">reified&lt;/span> &lt;span style="color:#a6e22e">F&lt;/span> : &lt;span style="color:#a6e22e">Fragment&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Provider&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> F&amp;gt;.asFragmentFactory(): FragmentFactory {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">FragmentFactory&lt;/span>() {
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">instantiate&lt;/span>(classLoader: ClassLoader, className: String): Fragment {
&lt;span style="color:#66d9ef">val&lt;/span> fragmentClass = loadFragmentClass(classLoader, className)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (F&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">== &lt;/span>&lt;span style="color:#a6e22e">fragmentClass&lt;/span>) {
&lt;span style="color:#66d9ef">get&lt;/span>()
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">super&lt;/span>.instantiate(classLoader, className)
}
}
}
}
&lt;span style="color:#75715e">// MyActivity.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyActivity&lt;/span> : AppCompatActivity() {
&lt;span style="color:#a6e22e">@Inject&lt;/span>
&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">lateinit&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> fragmentProvider: Provider&amp;lt;MyFragment&amp;gt;
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">onCreate&lt;/span>(savedInstanceState: Bundle?) {
supportFragmentManager.fragmentFactory = fragmentProvider.asFragmentFactory()
&lt;span style="color:#66d9ef">super&lt;/span>.onCreate(savedInstanceState)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="composable-fragmentfactory">Composable FragmentFactory&lt;/h5>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// FragmentFactory.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typealias&lt;/span> FragmentProviderMap = Map&amp;lt;Class&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> Fragment&amp;gt;, &lt;span style="color:#a6e22e">@JvmSuppressWildcards&lt;/span> Provider&amp;lt;Fragment&amp;gt;&amp;gt;
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * A [FragmentFactory] that can hold onto multiple other FragmentFactory [Provider]&amp;#39;s.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Note this was designed to be used with [FragmentKey].
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CompositeFragmentFactory&lt;/span> &lt;span style="color:#a6e22e">@Inject&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> map: FragmentProviderMap
) : FragmentFactory() {
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">instantiate&lt;/span>(classLoader: ClassLoader, className: String): Fragment {
&lt;span style="color:#66d9ef">val&lt;/span> fragmentClass = loadFragmentClass(classLoader, className)
&lt;span style="color:#66d9ef">return&lt;/span> map[fragmentClass]&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">get&lt;/span>() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.instantiate(classLoader, className)
}
}
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * A [MapKey] annotation for maps with [KClass] of [Fragment] keys.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Note this was designed to be used only with [CompositeFragmentFactory].
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>(
AnnotationTarget.FUNCTION,
AnnotationTarget.PROPERTY_GETTER,
AnnotationTarget.PROPERTY_SETTER
)
&lt;span style="color:#a6e22e">@Retention&lt;/span>(value = AnnotationRetention.RUNTIME)
&lt;span style="color:#a6e22e">@MapKey&lt;/span>
&lt;span style="color:#66d9ef">annotation&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FragmentKey&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: KClass&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> Fragment&amp;gt;)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Similar to the &lt;code>CompositeViewModelFactory&lt;/code> you must do some additional setup.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// FragmentFactoryModule.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@Module&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">FragmentFactoryModule&lt;/span> {
&lt;span style="color:#a6e22e">@Binds&lt;/span>
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">provideFragmentFactory&lt;/span>(impl: CompositeFragmentFactory): FragmentFactory
&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>[Binds &lt;span style="color:#a6e22e">@IntoMap&lt;/span> &lt;span style="color:#a6e22e">@FragmentKey&lt;/span>(MyFragment1&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)]
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">provideFragment&lt;/span>(impl: MyFragment1): MyFragment1
&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>[Binds &lt;span style="color:#a6e22e">@IntoMap&lt;/span> &lt;span style="color:#a6e22e">@FragmentKey&lt;/span>(MyFragment2&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)]
&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">provideFragment&lt;/span>(impl: MyFragment2): MyFragment2
}
&lt;span style="color:#75715e">// MyActivity.kt
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyActivity&lt;/span> : AppCompatActivity() {
&lt;span style="color:#a6e22e">@Inject&lt;/span>
&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">lateinit&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> fragmentFactory: FragmentFactory &lt;span style="color:#75715e">// no need for a specific Factory
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">onCreate&lt;/span>(savedInstanceState: Bundle?) {
supportFragmentManager.fragmentFactory = fragmentFactory
&lt;span style="color:#66d9ef">super&lt;/span>.onCreate(savedInstanceState)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="conclusion">Conclusion&lt;/h4>
&lt;p>As you can see it is easy to support the Architecture Components combining Dagger with Kotlin features. I personally prefer the composite approach where we can fully hide the implementation details from the production code - Activities and Fragments aren&amp;rsquo;t aware of the &lt;code>javax.inject.Provider&lt;/code> interface - and the &amp;ldquo;glue&amp;rdquo; code is done inside Dagger modules with @ClassKey annotation style. Therefore, the additional might be an overkill for use cases where you want only one ViewModel or Fragment and these extension functions can be very handy if you don&amp;rsquo;t care to use the Provider directly.&lt;/p>
&lt;p>&lt;strong>Disclaimer:&lt;/strong> Note that you must connected the &lt;code>CompositeViewModelFactoryModule&lt;/code> and &lt;code>CompositeFragmentFactoryModule&lt;/code> to your Component. I propositally ommited this part to keep this tutorial short - if you need more information, check the &lt;a href="https://dagger.dev/">Dagger documentation&lt;/a>.&lt;/p></description></item><item><title>About</title><link>https://marcellogalhardo.dev/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marcellogalhardo.dev/about/</guid><description>&lt;p>Software engineer with over 5 years of experience with Android. I am a moderator of the Android Dev BR community, the largest network of Android developers in Brazil.&lt;/p>
&lt;h3 id="contact-me">Contact me&lt;/h3>
&lt;ul>
&lt;li>Email: &lt;a href="mailto:marcello.galhardo@gmail.com">marcello.galhardo@gmail.com&lt;/a>&lt;/li>
&lt;li>Twitter: &lt;a href="https://twitter.com/marcellogalhard">@marcellogalhard&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.linkedin.com/in/marcellogalhardo/">LinkedIn&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Talks</title><link>https://marcellogalhardo.dev/talks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://marcellogalhardo.dev/talks/</guid><description>&lt;ul>
&lt;li>June 05, 2019: &lt;a href="https://speakerdeck.com/marcellogalhardo/railway-oriented-programming-with-kotlin">Railway Oriented Programming with Kotlin&lt;/a>&lt;/li>
&lt;li>April 17, 2019: &lt;a href="https://speakerdeck.com/marcellogalhardo/effective-kotlin">Effective Kotlin&lt;/a>&lt;/li>
&lt;li>March 01, 2019: &lt;a href="https://speakerdeck.com/marcellogalhardo/modularizing-legacy-apps">Modularizing Legacy Apps&lt;/a>&lt;/li>
&lt;li>November 11, 2018: &lt;a href="https://speakerdeck.com/marcellogalhardo/android-modular-architecture">Android Modular Architecture&lt;/a>&lt;/li>
&lt;li>January 24, 2017: &lt;a href="https://speakerdeck.com/marcellogalhardo/introduction-to-dagger-2">Introduction to Dagger 2&lt;/a>&lt;/li>
&lt;li>January 24, 2017: &lt;a href="https://speakerdeck.com/marcellogalhardo/introducao-ao-dagger-2">IntroduÃ§Ã£o ao Dagger 2 (PT-BR)&lt;/a>&lt;/li>
&lt;li>September 06, 2016: &lt;a href="https://speakerdeck.com/marcellogalhardo/solid-no-desenvolvimento-android">SOLID no Android 2 (PT-BR)&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>